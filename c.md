=============================================================================================
=============================================================================================
==================================【C语言的基础】=============================================
代码1：

#include <stdio.h>
int main()
{
        printf(" c语言\nwww.zixue7.com\n");
        getch();
        return 0;
}

解释：include 定义文档开头 
      <stdio.h> 定义了开头文档是什么文件
      int 返回值  
      main() 主函数，所有C语言的入口函数
      /n 换行
      printf 输出一段后面括号中的字串符
       ("c语言\nwww.zixue7.com\n") printf 函数的输出值，输出的字串符，也就是内容
      getch(); 等待用户输入，暂停窗口，不让程序马上退出
      return 0; 退出程序  参数0表示正常退出 返回给操作系统

代码2:
#include<stdio.h>
int main(void)
{
         int dogs;
         printf ("How many dogs do have?\n");
         scanf ("%d",&dogs);
         printf("So you nave %d dog(s)!\n", dogs);
         return 0;
}

代码3：
          程序清单 1.2 Concrete.c 程序
----
#include<stdio.h>
int main (void)
{
         printf("concrete contains gravel and cement.\n");
         return 0;
}

		=======================数据的类型
 关键字
int，short，long，char，float，duble，（unsigned 不是 也就是无符号数全是正数 用上 %u的占位符）单引号定义字符，双引号定义字符串
定义整数或浮点数的类型
 运算符
*注意*
	sizeof()函数可以用来计算数类型的大小
*注意*

scanf（）

 整型的数的定义，也就是变量的定义
 int/long/short/char/float/duble 后接交关键字的名字 名字不能以数字开头，也不能全是数字，只能是以下划线或字母开头.(变量名可以随意取)整型只能表示16位(int) 都表示有符号数 可以是正数 也可以是负数

比如：
定义数据的整型
 
 关键字   变量名  本身赋的值
 int        i      =0;
 short      s      =2;
 long       l      =10;
 char       c      ='0';
 float      f      =5.5;
 double     d      =15.5;
          
    当数据类型定义好后 在变量名后赋值
在char 数据类型中 可以在单引号中表示一个值或字符 单引号中的值和其它所赋的值不一样。double比float更精确


   <变量名中   int i=0;  int k=0; = int i=0,k=0;>


赋值的方式有三种：
1.int i=0;
2.int i;   
  i=0; (运行的过程中赋值)
3.
  a.直接输出字符
 printf("%d",&i) （i即等于0）
           */%d d:输出整型的数 %f f:输出小数的数 格式化输出：.1f% 输出一位小数  &i i:变量名*/

 b.等待用户自行输入字符：
  scanf("%d",&i); （先由用户输入一个值）
  printf("%d",i); （在显示刚才用户输入的值）

 c.输出已有的字符 在等待用户输入赋值：
  
  printf("%d",&i); （先输出一个i的值）
  scanf("%d",&i);  （在由用户输入一个i的值）
  printf("%d",i);  （最后，在输出i的值）
   

--如果数据类型为
  char  c='0';
        那么 在后面输出的数是字符型（因为，在计算机中，字符型数的表示方式是ascll码，所以0将输出与ascll码中对应十进制的0的值，将输出的是48，如果char=48 那么 char='0' = char=48   
              那么，又如果想让char='0' 就输出0  那在函数printf中 printf("c%",c)）    


		==============字符串
首先格式：
  关键字   数组名    控制符         赋值       
   char       c      ['字长']      =“  ”    \0
  （用“”和‘ ’是不样的，“”定义的是字符串，‘ ’定义的是单个字符）

比如：
      char c[7]="我的心";
      printf("%s",c);

在关键字前加上 const 常量定义，会让运行过程中的数不被修改，或是在头文件一下加上#define 后跟数组名以及值

		===============格式化输出

占位符：

%d	整型数占位 
%f	浮点数占位 
%o	八进制数占位 
%u	无符号数占位
%c	字符型占位符 
%s	字符串占位符 
%x	十六进制数站位符 
%e	浮点数e- E-计数法
%p	地址占位符

其中转义字符：

转义字符      意义                            ASCII码值（十进制）
   \a      响铃(BEL)                                 007
   \b      退格(BS) ，将当前位置移到前一列           008
   \f      换页(FF)，将当前位置移到下页开头          012
   \n      换行(LF) ，将当前位置移到下一行开头       010
   \r      回车(CR) ，将当前位置移到本行开头         013
   \t      水平制表(HT) （跳到下一个TAB位置）        009
   \v      垂直制表(VT)                              011
   \\      代表一个反斜线字符''\'                    092
   \'      代表一个单引号（撇号）字符                039
   \"      代表一个双引号字符                        034
   \0      空字符(NULL)                              000
   \ddd    1到3位八进制数所代表的任意字符        三位八进制
   \xhh    1到2位十六进制所代表的任意字符        二位十六进制


		===============格式化输入

首先格式：
scanf("%点位符","&数组地址")
 如下：
	char str[521]="数组值"
	scanf("%s","str")

int/long/short/char/float/duble 变量


		==============专讲printf()的字域宽度，和scanf()输入方式

printf("%d",12345);  原样输出
printf("%2d",12345); 超出二位原样输出
printf("%10d",12345); 不足10位 右对齐
printf("%08d",12345); 不足8位 前面0填充
printf("%-10",12345); 不足10位 左对齐

格式：
scanf("%d,%d",&a,%d);

如：
	int j,b,h;
	scanf("%d+%d=",&j,&b);
	h=j+b;
	printf("%d+%d=%d",j,b,h);
	 return 0;
		==============基本运算符
+、-、*、/、=

在浮点运算double 变量中，需要%Lf 进行双精度运算
 比如 ：
	double a,b,c;
	scanf("%Lf%Lf",&a,&b);
	c = a + b;
	printf("%.2f+.2f%=.2f%",a,b,c);
	 return 0;

*、/ 运算用双精度型运行程序处理
	乘法：
		double a, b, c;
		scanf("%Lf,%Lf", &a, &b);
		c = a * b;
		printf("%.2f*%.2f=%.2f", a, b, c);
		 return 0;
类型强制转化符：()值
	如:
		printf("%f",5/2);		（错误）
		printf("%f",(double)5/2);	（正确）
        		其中((double)5/2)=(5.0/2)

		==============其他运算符
1.%	取余符号
2.自增 自减  ++  --
3.运算符优先级


	-------首先% 取余符号
	比如：
		
		printf("%d", 5%2);
		return 0;
	此代码会得到一个数 1 ∵5/2=2...1 余数是1 ∴5%2=1

	-------自增和自减（比较困难、复杂）

比如：
		int i=0;
		i++(或--);
		printf("%d",i);
		return 0;
				最后的结果竟然是 1(或是-1)
            ∵在自增或自减的运算中 
		自增（++）会让所定义的一个变量让自身加上一个数 1
		自减（--）会让所定义的一个变量让自身减上一个数 1

   但是，如果将以上代码放在这
			int i=0;
			
			printf("%d",i++(或--));
			return 0;

	         ==   i++； =i+1；
	其最后的结果是i的本身变量 0
          
        就像这样 如果在将前面的i++(或--)变为++(或--)i效果就会变为结果 1或-1

也就是因为 
		i++(或--)  //先进行运算，在加减 
	      而++(或--)i  //先进行加减，在运算

*****重点*****

	在运算中，i++和++i是不同运算的顺序，
	上面的代码(i++)之所以没有将结果显示为1 	是因为printf函数是先进行了变量 i的运算　
	在运算了自增（++），如果非要进行这样的运算，
	必须在此printf函数下，再写一个prinrf函数，
	当然，第二个函数中的占位符后就不在变量i前加++了，
	因为，前面的那那个函数最后已经运算了++***********************

*****重点*****
--优先级 =见表

		==============表达式和语句

像 4；4+6；6+5；5*6； 等等 都是表达式的方式

又如 ： ， 逗号 表达式

--逗号表达式可以分隔表达式

	比如：
		int a=0;
		a=(1,2,3);
		printf("%d",a);
	此代码将a 这个表达式 a=1,2,3;  分离成了a=(1，2，3);
		本身此代码的运算顺序是 a=1,a=2,a=3; 可就是因为有逗号表达式，所以，则将a=1,2,3；这个表达式运算顺序变成了 a=1 =2 =3; ∴a=(1，2，3) 最后的结果是运算到最后的值 为3  ；
		
 /*此时一定会有人问，这样还不如直接a=3; 不是吗？ 当然可以，但是，因为，逗号运算符是让运算从左到时右一次运算，如果，在运算到时左边的那个数时改变了前一个自变量的值，就会影响到后面的自变量的值，所以，就为能直接 a=3 了。*/

  		上述比如实例：
			a=0 b=0;
			a=(b=b+1,b=b-2,b);
			printf("%d",a);
			return 0;

  			这样最后的值就不是0了 而是 -1

	-------数类型 自动转换和强制转换
 自动转换：
		int i;
		float f;
		i=95;
		f=100.95;
		i=f;
		printf("%d",i);
  猜猜看看，这个结果是多少，这就是自动转换。
 强制转换(指派类型)：我们想要让整数的100除以3显示为小数。
		
		int i;
		i=100;
		printf("%f",(float)i/3);
		return 0;

这样就能达到我们想要的结果了。为33.33333
** 
  注意：
	这里的指派(float)并不是将i这个数变为的浮点数，而是只是在此处让这个整数显示为浮点数。
**

=============================================================================================
============================================================================================
==============================【循环语句】==================================================
		
		==============while循环语句
看这个代码：

	int i=0;
	while(i<100)
	{
		printf("%d,",i);
		i++;
	}
		return 0;

**while //是先判断条件，在执行代码

		=============do-while循环语句	

	int i=0;
	//do while循环体
	do
	{
		printf("%d,",i++);
	}while(i<100);
		return 0;

**do while //是先执行代码，在判断条件

while 于 do-while的用法的不同

比如：do-while语句


	char ch;
	do
	{
		scanf("%C",&ch);
	}while(ch<'a' || ch>'z');

	printf("%c\n",ch-('a'-'A') );
	return 0;
	
	//就是让用户输入一个数后在循环的运行do-while这个语句，并且还要满足<ASCLL中 a 的值 或者是>ASCLL中 A 的值，用户输入的值如果满足此条件，就会等到最后的 变量c的值 ，如果不满足这个条件，系统将让用户一直输入下去。


		===================for循环

 首先，格式：

for(初始化;条件;改变条件)
{
	循环体；
}

return 0;


	for语句在循环语句中，是比较灵活的，运用也比较广泛，
	但是，for 语句学习中，也是比较复杂的。

那么，我们就先来看看代码：
	
#include <stdio.h>
int main()
{
	int i=0;

	for(i=0;i<127;i++);
	{
		printf("%3C",i);
	}
	return 0;
}

此语句的作用是，在ASCLL中让i这个变量，初始化为0后，在让变量i<ASCLL码中的对应127这个值时，就让变量i循环自增，也就让变量i在ACSLL码中的值循环下去。

	------for 语句的多变情况 例1：

int main()
{
	int i=0;
	for(i=0;i<127;i++)
	{
		printf("%3d%c ",i,i);
	      
	        if((i+1)%10==0)
		  {
			printf("\n");
		  }
	}
	return 0;
}

//用3个字符显示，从i=0 至 i=127中的ACSLL值，并在每个值前面显示所对应的ASSLL值。一直循环。


此语句看起来比较就比较复杂多了，而且还加入了一个if语句，这样，for语句和if语句的套用，就比较复杂了。当然，输出的结果也就不同了。


或：

int main()
{
	int i=0;
	for(i=0;i<127;i++)
	{
		printf("%3d%c3",i,i);
	}
	return 0;
}

或：（用while语句实现）
int main()
{
	int i=0;
	while(i<127)
	{
		printf("%3d%3c",i,i);
		i++;
	}
	return 0;
}

或：（初始化多个变量）
int main()
{
	int i=0,n=0;
	for(i=1,n=1;i<5,i++)
	{
		printf("%d",i);
	}
	return 0;
}

或：（直接用for语句表示出来）
int main()
{
	int i=0,n=0;
	for(i=1,n=1;i<5;printf("%d",i),i++);
	return 0;
}


		===============表达式和关系运算符

 =  是赋值运算
 ！ 是非运算
 && 是与运算
 || 是或运算

		=============== 赋值运算 

运算符： +=、-=、*=、/=、%=

好比：

	int i=1;
	i+=2;(i=i+2)
结果变量i 的值为 3;
其它的运算符也如此。

		===============for 循环嵌套
	


比如：
#include <stdio.h>
int main()
{
	int i=0, n=0;
	
	for(i=0; i<5; i++)
	{
		for(n=0; n<10; n++)
		{
			printf("*");	
		}
		printf("\n");
	}
	return 0;
}
用第一个 for 语句运算后的 i 循环了 5次，那么就会有5排，
用第二个 for 语句运算后的 n 循环了
 10次 那么就会有每排10列


结果就是：

**********
**********
**********
**********
**********



===========================================================================================
===========================================================================================
============================【分支跳转】=====================================================


		================if语句

格式：
	1. if(条件)
		满足条件所执行的语句

	2. if(条件)
	   {
		满足条件所执行的语句
	   }
		

	if 语句的典型应用：

int main()
{
	char ch;
	scanf("%c",&ch);
	
	if(ch>='a' && ch<='z')
	{
		printf("您输入的%c是正确的",ch);
	}
	return 0;
}

此语句会让用户输入一人字符，如果此字符是 >=a 和 <=z 那么 将会显示
	“你输入的（用户输入的字符）是正确的”


		================if else 语句 

格式：
	if(条件)
	{
		满足条件所执行的语句
	}else
		{
			不满足条件所执行的语句
		}

		================if \else-if \? 语句 

--if-else 语句：

int main()
{
	char ch;
	scanf("%c",&ch);
	
	if(ch >= '0' && ch < '5')
	{
		printf("0-4",ch);
	}
	else if(ch >= '5' && ch < '7')
	{
		printf("5-6",ch);
	}
	else if(ch >= '7' && ch <= '9')
	{
		printf("7-10",ch);
	}
	........
	.......	
	......

	return 0;
}

此语句的作用是，从 if(ch >='0' && ch <'5')条件开始，如果满足条件，就输出 “0-4”
如果，不满足条件，就输出 “5-6” ，如果，还是不满足条件，就输出，“7-10”
 
一次的循环下去，直到满足该条件为止。

		============= ? 语句

	--------------利用 ？（三目） if-else 作比较

	int i=0;
	scanf("%D",&i);

	if(i>10)
	{
		printf(">10");
	}
	else
	{
		printf("<10");
	}
	return 0;

此语句是让用户输入一个数，让代码判断这个数是否>10 或 <10 
比如，输入 1 ，将会显示 “<10” 如果输入  100 ，将会显示 “>10”


**
但是，在利用率中，用 “？”运算符比 if-else 更简单
	用？ 运算符：

	int i=0;
	scanf("%D",&i);
	
	(i>10)?printf(">10"):printf("<10");

	return 0;

此语句也能达到上个代码的效果

/*-------------------------
*：作业，利用循环语句，作一个乘法口诀表

#include<stdio.h> 
int main() 
{ 
	int i,n; 

	for(i=0;i<10;i++) 
	{ 

		for(n=1;n<=i;n++) 
			printf("%d*%d=%d ",i,n,i*n); 
		printf("\n"); 
	} 
}

-------------------------*/


		====================continue 和 break 语句（c语言循环语句辅助手段）

**
首先用循环语句输出一个从 1--50 的所有奇数  用while 语句，

		-------------利用while 语句 + if 语句
如下：

	int i=0;
	while(i<50)
	{
		i++;
		if(i%2 !=0)
		{
			printf("%d\n",i);
		}
		
	}
	return 0;

或者是：

	int i=0;
	while(i<50)
	{
		i++;
		if(i%2 !=0)
		{
			//printf("%d\n",i);
		}
		else
		{
			printf("%d\n",i);
		}
	}

	return 0;

		---------利用 continue 语句
	int i=0;
	while（i<50）
	{
		i++;
		if(i%2 ==0)
		{
			continue;  //停止当前的循环，进入下一轮的循环
		}
		printf("%d\n",i);
		
	}
	return 0;

-----------!stop

		========--- break 语句 

	int i=0;
	while（i<50）
	{
		i++;
		if(i%2 !=0)
		{
			break;  //停止整个循环语句
		}
		printf("%d\n",i);
		
	}
	return 0;

就像，从0--100中，输出变量 i=50时，

	int i=0;
	while（i<50）
	{
		i++;
		if(i%2 !=0)
		{
			printf("%d\n",i);
			break;  //停止整个循环语句
		}
		
		
	}
	return 0;

		==================== switch-break 语句

/*---------
首先看一道题：
根据用户输入的分数，平等级。

60分及以下为 不及格

50-90分为 良

90及以上为 优


代码如下：

#include <stdio.h>
int main()
{
	double fs=0;
	
	printf("请输入您的分数");
	scanf("%lf",&fs);

		if(fs>=0  && fs<60)
		{
			printf("不及格");
		}
		else if(fs>=60  && fs<90)
		{
			printf("良");
		}
		else if(fs>=90  && fs<=100)
		{
			printf("优");
		}
		else
		{
			printf("请输入正确的分数");
		}	
	
		
	return 0;
}


-----------*/

		-------------switch-break 语句

格式：
	
	switch(条件)  //条件必须是整型的数
	{
		case 1:printf("一");break;
		case 2:printf("二");break;
		case 3:printf("三");break;
		case 4:printf("四");break;
		.........
		...........
		defalute:break;

	}


比如：

	int i=0;
	scanf("%d",&i);

	switch(i)
	{
		case 1:printf("一");break;
		case 2:printf("二");break;
		case 3:printf("三");break;
		case 4:printf("四");break;
		defalute:break;
	}
	return 0;

此语句的作用是，当用户输入i这个变量时，
	i为 1 时，输出“一”
	i为 2 时，输出“二”
	i为 3 时，输出“三”
	i为 4 时，输出“四”

	i没有值时，停止输出。

*注意*

	浮点数被强制转化为整数时，浮点数后的小数会被消掉。

*注意*

	
	
	∴利用switch-break语句实现第一题的方法是：

	doubel fs=0;
	scanf("%lf",&fs);

	switch((int)fs/10)
	{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:printf("等级：不及格");break;
		case 6:
		case 7:
		case 8:printf("等级：良");break;
		case 9:
		case 10:printf("等级：优");break;
		defalute:printf("请输入正确的分数");break;
	}
	return 0;
	

		===================== goto 跳转
格式：
	标签:
	goto 标签名;



*注意*
	因为 goto 语句的程序复杂，所以不是很常用，
	但在某些应用中会用上goto的语句，
*注意*


	---比如：

	qq:
	printf("www.qq.com");
	
	goto qq;

就这样的语句能够比运行到 “printf("www.qq.com");” 在运行到 “goto qq;”这个语句时，
将会从 “printf("www.qq.com");”此语句一直运行下去，就有点循环的意思了。

_______________并且 goto 语句可以跳转至程序的任何地方。__________________




		===========字符输入/输出和输入确认


首先，三个函数 

	1.getchar()	2.putchar()	3.getch()



------------- getchar()

等待用户输入的一个字符。获取键盘上的一个字符。

	printf("%c\n",getchar());




------------- putchar()
只能用来用户输入一个字符型字符。比如：char 数的类型


就像用getchar()函数做一个 有“#”号停止用户输入的循环

	char ch;
	ch = getchar();

	while(ch !=#)
	{
		getchar(ch);
		ch = getchar();
	}

	printf("%c\n",ch);


/*
scanf()函数和getchar()函数在输入时会立即显示出来
*/



------------- getch()
*注意*
	getch() 用户输入时不回显(也就是不按回车显示输入的字符)
*注意*

	char ch;
	ch = getcha();

	while(ch !=#)
	{
		getchar(ch);
		ch = getch();
	}

	printf("%c\n",ch);


也可以
	char ch;
	ch = getcha();
	


/*====================================================================

		===========循环语句和分支跳转的复习

一、利用 do-while 循环语句 和 while  if 语句实现从 1-100 的奇数输出：

1.利用 do-while 语句：

	int i=0;
	do
	{
		i++;
		printf("%d\n",i);
		i++;
	
	}while(i<100);

	return 0;

2.利用 while if 语句:

	int i=0;
	while()
	{
		i++;
		if(i%2 !=0)
		{
			printf("%d\n",i);
		}
	

	}

	return 0;

二、能让变量 i 从 0 无限的输出 0 以上的数字 不停止。

1.
	int i=0;
	
	xy:
	do
	{
		i++;
		printf("%d\n",i);
		
	}while(i<1);
	goto xy;
	
	return 0;

三、乘法口诀表的编写：
1.
	int i,n; 

	for(n=0;n<10;n++) 
	{ 

		for(i=1;i<=n;i++)
		{			
			printf("%d*%d=%d ",i,n,i*n);
		}

		printf("\n"); 
	} 
	return 0;

四、数的无限循环运算

1.一个有限数与无限的数的循环运算：
	int i,n;
	for(i=0;i<10;i++)
	{
		do
		{
			printf("%d+%d=%d ",i,n,i+n);
			n++;
		}while(n !=0);
		printf("\n");
		
	}
	return 0;

2.两个无限数的自增的循环运算：

	int i,n;
	n=0;
	do
	{
		for(i=0;i<=n;i++)
		{
			printf("%d+%d=%d ",i,n,i+n);
			n++;
			
		}	
			
		printf("\n");
	}while(n=0);
	return 0;





========================================================================*/


==============================================================================================
==============================================================================================
========================= 【指针】 =======================================================



			==========认识指针

详见：百度查询


			==========指针的简单用法

格式：

类型 空格 * 指针名

比如：

	int *pi;
	char *pc;
	double *pd;

			---------指针的赋值
定义时的赋值:
	
	int a=10;
	int *pa = &a;

定义后的赋值：

	int a=10;
	int *pa;
	pa=&a;

			---------获取指针指向的值

*指针

*p



		------应用：
例一：
	int mian()
	{
		char n='a';
		char *pn = &n;
		printf("n:%c\n n的地址:%d\n pn:%d\n pn的地址:%d\n pn指向的值:%c",
		n, &n, pn, &pn, *pn);
	
	}
	return 0;

//*pn 取值 取指针指向的地址中的值

		------------指针的总结

◤1◥
1.变量的值等于定义的值
2.变量的地址等于它本身的地址
3.指针的名等于变量的地址
4.指针的地址等于它本身的地址
5.指针的值等于变量值


/*
就好比：
	int mian()
	{
		char n='a';
		char *pn = &n;
		printf("n:%c\n n的地址:%d\n pn:%d\n pn的地址:%d\n pn指向的值:%c",
		n, &n, pn, &pn, *pn);
	
	}
其中：
	1.n = a
	2.&n = 2293583
	3.pn = &n
	4.&pn = 2293576
	5.*pn = n
*/

例二：

	int main()
	{
		int i=10,n=20;
		int *p;
		p = &n;
		*p = 30;
		printf("%d\n%d",i,n);
	}





			==========指针的字符串指针详解

例：

	char *str = "www.qq.com";
	printf("%c",str);
	return 0;			//获取"www.qq.com"，中的全部



	char *str = "www.qq.com";
	printf("%s",*str);
	return 0;			//只获取"www.qq.com"中的w


//两种不同的结果


/*
如果：char 中的变量 *str的值等于"www.qq.com";
那么要输出 *str的值有两种方法

      1.char *str = "www.qq.com";
	printf("%c",*(str+9));
	return 0;

      2.利用while语句	
	char *str = "www.qq.com";
	while(*str !='\0')		//因为在字符中，每个字符后面都会有个\0的转义字符
	{
		putchar(*str);
		str++;
	}
	
	return 0;


*****重点*****
		如果想让*str 从当中的某个字符开始输出，那就需要加上
	str+=?  
			//？ 号代表的在第几个字符d
**
*/

/*
	--------之如何获取一个字符串中的随意的一串字符

利用char 关键字 定义一个变量 strs
在利用char 关键字 定义一个指针变量 *str 让*str 赋值为strs 这个变量的地址
再 *（str+?）='\0';

最后直接输出这个指针变量的第几个字符



	char strs[20]="www.zixue7.com\0";
	char *str = strs;
	*(str+10)='\0';
	printf("%s",str+4);
	return 0;

此语句将会输出 ”zixue7“这一串字符

*/

******重点****

*/*
	//在 int *pi = &i;中 *pi表示指针 pi 这个变量
	/*在 printf("%d\n%d\n%d\n%d\n%d",i,&i,pi,&pi,*pi); 中的*pi表示取得 int 中定义的指针变量 pi 的值
		其中 的 pi 就是在int 关键字中定义的指针变量 *pi 中 Pi的值， 因为，*pi= &i，也就是 pi 等于 i 的地址
	*/
*/**

=============================================================================================
==============================================================================================
=========================  【数组】  ======================================================

			=======定义数组
1.定义数组
2.初始化数组
3.通过下标访问数组
4.数组下标从0开始



		----定义数组

int i[数组的个数];


		----初始化数组

1.
	int i[10]={1,2,3,4,5,6,7,8,9,10};

2.
	int i[10]={0};
3.
	int i[10];
	i[0]={1};
		----通过下标访问数组
1.
	int i[10]={1,2,3,4,5,6,7,8,9,10};
	i[0];
	printf("%d",i[0]);
2.
	int i[10]={1,2,3,4,5,6,7,8,9,10};
	int n=0;
	printf("%d", i[n]);

		----数组从0开始
1.
	int i[10]={1,2,3,4,5,6,7,8,9,10};

	int i[0];
	printf("%d",i[0]);
	

应用：

 	利用 for 语句输出数组 i[10]={1,2,3,4,5,6,7,8,9,10};

int i[10]={1,2,3,4,5,6,7,8,9,10};
int n=0;

for(i=0; i<10; i++)
{
	printf("%d\n",i[n]);
}

return 0;



			============一维数组的使用
十进制到二进制的转化：
	例子：

		----整形的数转化为二进制
	
//yu[16]是表示，因为，整形的数一般表示为两个字节，所以就是16位

	int n=0,i=0,yu[16]={0};
	printf("请输入一个0-32767之间的整数：");
	
//整数的范围是0-32767
	scanf("%d",&n);
	if(n ==0)
	{
		printf("0");
		return 0;
	}
	for(i=0;i<16;i++)
	{
		yu[i]=n % 2;
		n /= 2;
	}	

	i=15;
	while(yu[i] != 1){i--;}	

	for(; i>=0; i--)
	{
		printf("%d",yu[i]);
		
		if(i%4 == 0)
		{
			printf(" ");
		}
	}

	return 0;

**
	注意在此数组的一维使用中，比较复杂，需要下来后自己研究、
**


			============二维数组和多维数组
例子：

#include <stdio.h>
#include <conic.h>

int main()
{
	int i,n;
	
	int map[5][4]=			//[5]可省略 [4]不可省略
	{
		{1,2,3,4},
		{1,2,3,4},
		{1,2,3,4},
		{1,2,3,4},
		{1,2,3,4}
	
	};

	for(i=0; i<5; i++)
	{
		for(n=0; n<4; n++)
		{
			printf("%d\t",map[i][n]);   //\t 是转义字符，表示一个制表符	
		}
		printf("\n");
	}


	getch();
	return 0;

}

		--------------二维数组的应用


/*
	做一个坦克游戏的墙壁
*/

	int i,n;
	int map[5][4]=
	{
		{10,10,10,10},
		{10,0,0,10},
		{10,0,0,10},
		{10,0,0,10},
		{10,10,10,10}
	
	};

	for(i=0; i<5; i++)
	{
		for(n=0; n<4; n++)
		{
			if(map[i][n]==10)
			{
				printf("*");
			}
			if(map[i][n]==0)
			{
				printf(" ");
			}
		}	
			printf("\n");
	}

	getch();
	return 0;

				============数组指向的指针
例子：

#include <stdio.h>
int main()
{
	//我们用此代码输出数组i中　５；
	int i[10]={1,2,3,4,5,6,7,8,9,10};
	int *pi = i;
	printf("方法一:%d\n", i[4]);//方法一 直接利用变量i数组中的第五个数
	printf("方法二:%d\n",pi[4]);//方法二 利用指针变量 pi取 变量i 中5 的地址
	printf("方法三:%d\n",*(pi+4));//方法三 利用指针变量pi 在变量i中的地址 + 4 输出 5;
	printf("方法四:%d\n",*(i+4));//方法四 利用变量i 的地址 和 指针变量pi 在变量i中的地址一样 + 4 输出 5;

	return 0;
}



				===============C保护数组内容const的使用
常量指针 和 指针常量 


指针常量：指针是个常量		
	比如：

	const int i[10]={1,2,3,4,5,6,7,8,9,10},s[0]={0};

	int * const pi = i;	//可修改指针中的常量


常量指针： 指向常量的一个指针

	pi = s; 


				==============指向多维数组的指针
例如：

	int map[4][3]={
		{11,12,13},
		{21,22,23},
		{31,23,33},		
		{41,24,43},
				};
	int (*p)[3] = map;

	printf("%d",*p);	//输出指针p的地址
	printf("%d",**p);	//输出指针p的取值
	printf("%d",**(p+1));	//输出指针向map 数组的第一行 第一个数

	printf("%d",*(*(p+1)+1));	//输出指针向map 数组的第一行 第一个数

/*
	函数sizeof（）输出数占的字节数
	%p 输出地址的占位符
*/



==============================================================================================
============================================================================================
===========================【函数】====================================================

定义了函数中的内容的后，就可以直接调用这个函数中的内容。

int main(){}	此函数是需要返回的函数 就需要	return 0;（回复/返回）

void main(){}	此函数是不用返回的函数 就不需要   return 0;


			============函数的定义和调用

首先，最简单的定义函数和调用函数，实现调用函数输出一串“*” 号;
如下：

#include <stdio.h>
void myprintf();	//定义一个函数，让它存在，其中，"myprintf"是自定义函数的名称

int main()
{
	myprintf();	//这里就是直接的调用“myprintf”这个函数（可以多次的调用函数）
	return 0;
}

//定义这个函数的内容，就可以用函数名来直接的调用此函数的内容了
void myprintf()		
{
	printf("********\n");	
}


			===========定义带参数的函数

#include <stdio.h>
void myprintf();

int main()
{
	myprintf(10);	//“myprintf(10)”中的 10 表示有十个myprintf() 这个函数的参数
	return 0;	//这个 10 也就是下面定义函数中的参数时所定义的变量 n 是多少
}

void myprintf(int n)	//函数 void myprintf(int n),中定义了一个参数，
			  一个整型的数 并定义 了一个变量 n 
{
//在void myprintf() 函数中利用for 语句实现了一个循环，
	int i=0;
	for(i=0; i<n; i++)
	{
		printf("*");		
	}
	
}

此语句将输出十个“*”号。


		------利用调用函数的方法，实现用for 循环语句的效果：

#include <stdio.h>
void myprintf();

int main()
{
	int i=0;
	for(i=0; i<10; i++)
	{
		myprintf(10);
		printf("\n");
	}
	
	return 0;
}

void myprintf(int n)	
{
	int i=0;
	for(i=0; i<n; i++)
	{
		printf("*");
	}		
}
//可以实现for的循环	

此函数就可以减少利用for循环的效果的代码多少。

/*=========================================================
			-----实现三角形式的排列
#include <stdio.h>
 void myprintf();


int main() 
{ 
	int i,n; 

	for(i=0;i<10;i++) 
	{ 
		myprintf(i);	//为什么要传个i 不会传i的话，将会是死循环，
				  因为，没有定义多少列，多少排，所以将是死循环
		printf("\n");
	} 
}


 void myprintf(int n)	
 {
	 int i;
	 for(i=0; i<n; i++)
	 {
		 printf("*");
		
	 }
 } 
================================================*/
****重点********
		-----------为什么调用函数myprintf()时要传个i，
比较：
for(i=0;i<10;i++) 
	{ 
		for(n=1;n<=i;n++) 
		{
			printf("%d*%d=%d ",i,n,i*n); 
		}
		printf("\n"); 
	} 


	不会传i的话，将会是死循环,因为，没有定义多少列，多少排，所以将是死循环。   在函数,myprintf()中，定义了一列的“*”号，并且让它实现了（ main()函数中的for（）语句中的 i<10)十排，但是这里只有一列，就必须要在myprintf()函数中实现i<n 的十列，然后在一个一个的加上来实现三角形式的“*”号输出，所以需要在myprintf()函数中传递一个i.
 n 就是mypritnf()函数的本身  所以放在main()函数中时，还少了一个 <=的对象，还少了一个然后这个对象就是main()函数中的for（）语句中的变量i ， 所以得传递一个这个变量i


详情，请看文件。“传递 i.c”
****重点*****

/*◤7◥
	---------利用函数的调用，输出小写转大写的效果
	
#include <stdio.h>
void mychar(char);

int main() 
{ 
	char c;
	c = getchar();
	mychar(c);

	return 0;
}

void mychar(char ch)
{
	if(ch>='a' && ch<='z')
	{
		putchar(ch - ('a'-'A'));
	}else{
		putchar(ch);		
	}
	
}	

*/

/*
	作业：

	利用函数的调用，做出乘法口诀表;
#include <stdio.h>
void xf();
int main()
{
	int i, n;
	for(n=1; n<10; n++)
	{
		xf(n);
		printf("\n");
	}
	
}

void xf(int m)
{
	int i;
	for(i=1; i<=m; i++)
	{
		printf("%d*%d=%d ",i,m,i*m);
	}
	
}

*/


			================函数之形参和实参

函数的形参和实参是指，形式的参数 和 实际的参数;

传递给函数的参数就是实际参数;
在调用前定义的参数就是形式参数;

一个例子：

#include <stdio.h>

void add(int, int,);

int main()
{
	add(5,6);	//其中是实际参数	5表示 a  6表示 b 
	return 0;
}

void add(int a, int b)	//其中是形式参数 a 和 b 的整型变量
{
	printf("%d+%d=%d",a,b,a+b);
}


*注意*
	
	当有全局的变量时，和函数变量时，
	在函数变量中的形参会覆盖掉全局的变量
*注意*
就好比：

#include <stdio.h>
int a,b;		//在全局整型中定义两个变量 a  b
void add(int, int,);

int main()
{
	a=1;	b=2;	//在main（） 函数中给全局的变量 a b赋值 但是在次时，
			 main()函数中的 add(5，5) 调用这个函数时会先选择add()
			函数中的变量 a b 而不是 全局变量中a b  但又如果在add()
			函数中修改了其中的变量 int a, int b  那么此时main()函数
			中将使用全局变量中的 a b 变量

	add(5,5);	//其中是实际参数	5表示 a  5表示 b 
	return 0;
}

void add(int a, int b)	//其中是形式参数 a 和 b 的整型变量
{
	printf("%d+%d=%d",a,b,a+b);
}

****重点*******
//在main（） 函数中给全局的变量 a b赋值 但是在次时，
			 main()函数中的 add(5，5) 调用这个函数时会先选择add()
			函数中的变量 a b 而不是 全局变量中a b  但又如果在add()
			函数中修改了其中的变量 int a, int b  那么此时main()函数
			中将使用全局变量中的 a b 变量
****重点*******



			===========函数返回值和函数类型


			--------------函数的返回值

首先定义一个能够返回一个整型的类型的函数

其次在函数的返回值中利用 return 来实现

*注意*
	用了 return 语句后的返回值将不会在执行 return 后面的语句
*注意*

	---定义一个整型的函数：

int add(int a, int b);	//1.定义了一个名为 add 的整型函数

int main()
{
	printf("%d", add(2, 3) );	//3.最后调用 add() 函数并实现 add() 函数中
					//的整型的数的参数传递
					//（这里的参数就是 int 关键字定义的 a ,b)	
	return 0;
}

int add(int a, int b)	//2.实现了 add() 函数
{
	return a+b;
}

*----结果请编译一次看看

			--------函数的类型

函数的类型可以是任何的类型。(int\char\float\double\sthor\long ....)

如：

	float add(flaot a, float b);
	float add(flaot a, float b)
	{
		return a+b;
	}
	......
	.....
	...


********重点********
********重点*******

			*?*【=======------内存的分配】*?*
					◤6◥
让用户输入的一个字符串储存在一个缓冲空间中，在来输出此字符串
内存的分配首先要一个头文件 malloc.h 这个文件，这个文件中有许多的内存储存的函数以及其用法

/*=================================================================
如下：
#include <stdio.h>
#include <malloc.h>
#include <string.h>

char *getstr(); 	//此定义了一个指针指向的函数

int main()
{
//掌握好 puts()、 memset()、free ()、gets() 函数的用法

	char *p = NULL;	//5.在定义一个能够储存 str 缓冲空间中储存的字符串的指针
	p = getstr();	//6.让 p 这个指针指向 str 中的缓冲空间的指针的首地址
	puts(p);	//7.输出指针 p 所指向的缓冲空间中的字符串
	free(p);	//8.同第三步中的 memset() 函数样
			    需要在清除掉指针 p 储存的剩下的空间
	return 0;
}

char *getstr()
{
	char *str = NULL;	//1.先是让 char 所指向的指针为空（因为不知道有多大的空间储存）也就是输入的字符串的大小

//2.让这个空间计算出有多少的空间，也就是利用 sizeof() 函数开辟一个乘以 512 个字符型大小的空间
//双因为这个这空间没有类型，所以要强制转化一下类型所以 是 char *


	str = (char *)mallco(sizeof(char)*512);	

//3.以因为还有的没有用过的空间，所以还要清除掉剩下的空间利用 memset()  函数来实现
//并且 memset() 函数在 string.h 文件中

	memset(str, 0 , sizeof(char)*512);	

//4.gets() 函数是专门来获取一个字符串 这里是专门来返回 str 这个指针中的缓冲内存储存的字符串

	return gets(str);
}

//malloc（） 函数表示给内存一个缓冲的空间
=================================================================*/

puts()
memset()
mallco()
free()

*******重点********
*******重点********

*注意*
	数的返回不能是双精度型
*注意*

			◤13◥===========指针做函数的参数

首先要理清楚的东西是传值和传地址

【传值】

就像是把所传的值复制一份出来

比如：
		#include <stdio.h>
		void test(int);
		int main()
		{
			int a = 50;

			test(a);	

			return 0;
		}

		void test(int n)
		{
			printf("%d",n);	
			
		}

//这个效果将会是在 int main（） 函数中调用 test() 这个函数并把 n 的值传递给 main() 函数中的 int 变量 a 的值，也就是说将 n 的值传给 a　并执行 test() 函数中的 printf() 语句（输出这个传递后的 n 的值）

【传地址】（指针）

地址这个数据只有一份，访问和修改都是在同一份数据上操作的

比如：

#include <stdio.h>
void test(int *n);
int main()
{
	int a=50;
	printf("a 的值：%d\n",a);
	printf("a 的地址：%d\n",&a);
	
	test(&a);	//1.不是把 test() 中指针传递给 &a 的地址（不是 &a =n）。而是
			  &a(也就是利用 a 的地址找到 a 的值 )，然后再将test()
			  中的指针(n)传递给&a（利用 a 的地址找到的 a 的值）
			  

	printf("a 传递后的值：%d\n",a);	//2.所以在这里就会把 a 的值改变成 
					//带实参的test()
	printf("a 传递后的地址：%d",&a);	//3.而又这里的 &a（这个就是 a 真正的地址
					  因为 a 的地址并没有像 1. 说的那样被
					  test() 中的 n 传递了）
	
	return 0;
}

void test(int *n)
{	
	*n = 10;	//4.这里只是这定义了一个带指针的参数（n）的值为 10
			//然后在传递时也只是把这个值利用 &a 传递给了 1. 中
			//所说的 a 的值
}

//要看懂这段代码需要屡清指针与变量的关系   详见书签 --->|◤1◥


			==============数组作函数的参数

第一个例子:
例一：

#include <stdio.h>
void test(int []); 	//1.这里的 [] 表示是用数组来作为参数

int main()
{
	int n[5]={1,2,3,4,5}; 
	test(n);		//2.这里是传递了 n 这个数组的首地址传递了这个函数的地址
				//也就是传递了这整个数组；如果这是用数组的每一个值来作为
				//参数，那么整个函数是传递了某个值，就和下面的函数一样
				//见书签 --->|◤2◥
	return 0;
}
*注意*
	在 C 语言中，定义的变量不能在语句的下面。
*注意*
void test(int t[])
{
	int i;
	for(i=0; i<5; i++)	
	{
		printf("%d ", t[i] );	
		
	}		
}

//此例子就是用了数组来作为参数的传递
//将输出 1 2 3 4 5

例二：
◤2◥:
void test(int []);

int main()
{	
	int n[5]={1,2,3,4,5};
	test(n[0]);
	return 0;
}

void test(int t[])
{
	int i;
	for(i=0; i<5; i++)
	{
		printf("%d ", t[i]);
	}
}

//这个例子就是将函数 test() 传递了值，所以不论其它的怎么变，结果的值都是 n[0](1)。

/*--------------------------------------------------------
	------例一和例二的说明：
1.
void test(int);
int main()
{
	int i;
	int n[5]={1,2,3,4,5};
	test(n[0]);
	return 0;
}
void test(int a)
{
	printf("%d",a);		//将这里的实参传递给主函数的数组地址
}


2.

void test(int);
int main()
{
	int i=1;
	int n[5]={1,2,3,4,5};
	test(i);
	return 0;
}
void test(int a)
{
	printf("%d",a);		
}

以上两种方式都是一样的，所以说在数组作参数中，数组的单个元素和一个变量是一模一样的。

3.
void test(int);
int main()
{
	int i=1;
	int n[5]={1,2,3,4,5};
	test(n[0]);
	printf("%d", n[0]);
	return 0;
}
void test(int a)
{
	a=10;		/*我要修改这个参数*/
}

而在 3. 中，即使在函数中对参数的修改也不会对结果有影响。
因为在 3. 中， 是把 n[0] 当做传递的值了，而不是地址

------------------------------------------------------*/

在上述各函数中，函数中定义的数组的形参可以有长度，但是定义了也没有什么用，所以一般都不会去定义这个参数。

好比是：
	void test(int [5]);


			---------数组作参数时修改其值

我们在定义函数时，有两种传递的方式，一是传递地址，二是传递值。
在以数组定义函数的参数时如何去修改这份唯一的数据呢？	

下面的例子来说明这些：

我们来做个实验，看看传递完地址后的数组是否会让数据产生变化


void test(int []);
int main()
{
	int i,a;
	int n[5]={1,2,3,4,5};

//1.这里我们先输出最开始时数组 n 的值

	for(i=0; i<5; i++)
	{
		printf("%d", n[i]);
	}
	printf("\n");

//2.这里就是在被 test() 传递参数后的时候所输出的值

	test(n);
	
//3.这里就是在 test() 所传递参数后数组 n 的值

	for(i=0; i<5; i++)
	{
		printf("%d", n[i]);
	}
	return 0;
}

//这就不用说了吧！

void test(int t[])
{
	int i;
	for(i=0; i<5; i++)
	{
		t[i] = 5+i;
		printf("%d",t[i]);		
	}		
	printf("\n");
}


<！-------详请 请编译此段代码

当然在上面我们就说过可以防止数组中的数据遭到修改。
在定义函数时与实现函数时可以在形参前加上 const 来保护数据....


/*------------------
void test(int const []);
int main()
{
	int i,a;
	int n[5]={1,2,3,4,5};
	for(i=0; i<5; i++)
	{
		printf("%d", n[i]);
	}
	printf("\n");
	test(n);
	for(i=0; i<5; i++)
	{
		printf("%d", n[i]);
	}
	return 0;
}
void test(int const t[])
{
	int i;
	for(i=0; i<5; i++)
	{
		t[i] = 5+i;	//注释内容
		printf("%d",t[i]);		
	}		
	printf("\n");
}

因为，我们用了 const 来保护数组，所以就不能在对数据修改，所以在最后，我们必须在【注释内容】
中，把这句代码注释掉才能起到利用 const 保护数组数据的效果。
---------------*/


				===============函数的递归

			----------◤3◥----------
--------递归

    程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。


递归，就是在运行的过程中调用自己。

构成递归需具备的条件：

1. 子问题须与原始问题为同样的事，且更为简单；

2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。

例如，下列为某人祖先的递归定义：

某人的双亲是他的祖先（基本情况）。某人祖先的双亲同样是某人的祖先（递归步骤）。斐波纳契数列（Fibonacci Sequence），又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21..... I[1] 

斐波纳契数列是典型的递归案例：

递归关系就是实体自己和自己建立关系。
Fib(0) = 1 [基本情况] Fib(1) = 1 [基本情况] 对所有n > 1的整数：Fib(n) = (Fib(n-1) + Fib(n-2)) [递归定义] 尽管有许多数学函数均可以递归表示，但在实际应用中，递归定义的高开销往往会让人望而却步。

例如：

阶乘（1) = 1 [基本情况] 对所有n > 1的整数：阶乘（n) = (n * 阶乘（n-1)) [递归定义] 一种便于理解的心理模型，是认为递归定义对对象的定义是按照“先前定义的”同类对象来定义的。例如：你怎样才能移动100个箱子？答案：你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：你怎样才能移动99个箱子？最终，你的问题将变为怎样移动一个箱子，而这时你已经知道该怎么做的。
如此的定义在数学中十分常见。例如，集合论对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。



【递归算法一般用于解决三类问题】

(1)数据的定义是按递归定义的。（Fibonacci函数）
(2)问题解法按递归算法实现。
这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
(3)数据的结构形式是按递归定义的。
如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。

【递归的缺点】

递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。

递归的典型问题，见 梵塔问题（汉若塔问题）



				===============函数递归详解


（因为是第一次了解函数的递归，所以要知道它的定义）

【递归的定义】

	C 语言允许一个函数调用其本身，在这个被调用的过程就叫做递归。

详见书签 --->|◤3◥

在了解递归的同时需要去了解【阶乘】的意义，因为在这个一节中，要利用递归来算出【阶乘】

				-----------【阶乘】-----------

			---------------◤4◥----------


【阶乘的介绍】

阶乘是基斯顿·卡曼（Christian Kramp，1760～1826）于 1808 年发明的运算符号，是数学术语。

一个正整数的阶乘（英语：factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1。自然数n的阶乘写作n !。[ 1808年，基斯顿·卡曼引进这个表示法。]

*注意*

	亦即n!=1×2×3×...×n。

	阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。

*注意*


正整数阶乘指从 1 乘以 2 乘以 3 乘以 4 一直乘到所要求的数。
例如所要求的数是 4，则阶乘式是 1×2×3×4，得到的积是 24，24 就是 4 的阶乘。 例如所要求的数是 6，则阶乘式是 1×2×3×……×6，得到的积是 720，720 就是 6 的阶乘。例如所要求的数是 n，则阶乘式是 1×2×3×……×n，设得到的积是 x，x 就是 n 的阶乘[1]  。

【阶乘的表达方式】

任何大于 1 的自然数n 阶乘表示方法

	n! = 1×2×3×...（n-1）n   	||	n! = n×(n-1)!
 	
	
【二十以内数的阶乘】

以下列出 0 至 20 的阶乘：

0！=1（0 的阶乘是存在的，且定为1）
1！=1
2！=2
3！=6
4！=24
5！=120
6！=720
7！=5040
8！=40320
9！=362880
10！=3628800
11！=39916800
12！=479001600
13！=6227020800
14！=87178291200
15！=1307674368000
16！=20922789888000
17！=355687428096000
18！=6402373705728000
19！=121645100408832000
20！=2432902008176640000

而当 n≥5 时，n！的个位数字都是0。

在此阶乘就先说到这里进入本节的内容。


首先为实现【阶乘】的算法，来举个例子。

这个例子是用循环来实现 4 这个数的阶乘。

				==========---------使用循环来实现阶乘

因为循环实现阶乘是比较简单的方法。
如下：

	#include <stdio.h>

	int main()
	{
		long s, i;	//这里用 long 关键字，是因为阶乘的数是比较大在的整数类型
				//变量 s 用来存储阶乘的值；变量 i 用来存储阶乘的数（循环的数）

//***重点**
	在下面的 for 循环中，为什么要让变量 s 初始化为 1
	因为定义的 s　变量是用来存储阶乘的值，以及是每个阶乘的系数
在上面对阶乘的介绍说过，一个阶乘的数是　＝　n! = 1×2×..×(n-1)n	
这里的系数也就是每一个 1 2 3 4 .... (n-1)n 前的 1 
在 for 循环中，如果 s 初始化为 0 ，那么最后的变量 s 所保存的值不就只是 0 了吗,所以，要把变量 s 初始化为 1 ；
	for 循环中的 i <= 4 是因为，这节计算的是 4 的阶乘，以因为变量 i 是用来存储阶乘的数（循环的数），所以需要让 i <= 4;
	
***重点**
		for(i=1, s=1; i<=4; i++)
		{
			s *= i;	
		}		
		printf("%d",s);		//输出最后计算出来的 4 的阶乘
		return 0;
	}


上述就是利用循环计算出来 4 的阶乘。

				=======----------递归计算阶乘


递归求阶乘分析：

上面说了阶乘是怎么的算法，以及是什么格式，就比如这节求的 4 的阶乘

	4! = 1×2×3×4

◤5◥递归算法：

	
	算出 4! 可以先算出 3!×4
	算出 3! 可以先算出 2!×3
	算出 2! 可以先算出 1!×2
	1! 就等于 1 
	
如下：
//要利用 fact() 这个求阶乘的函数
	#include <stido.h>
	
	long fact(int);

	int main()
	{
		fact(4);
		return 0;
	}

	long fact(int n)
	{
		long f;
		if(n>1)
		{
			f = fact(n-1)*n;	//其这里的 fact() 就用来递归了	
		}else{
			f = 1;
		}
		return f;
		
	}

这个代码就是能够计算出 4! 的一个效果。详见请编译

		
/*=================================================================================
			----------------上述递归的计算原理

	#include <stido.h>
	
	long fact(int);		//1.首先定义一个递归计算的函数;fact()

	int main()
	{
		printf("%d",fact(4));
		return 0;
	}

	long fact(int n)	//2.实现这个函数
	{
		long f;		//3.因为上面说了，阶乘的值会比较大
*注意*
	下面的 if - else 语句的作用很重要
/*
	4! = 1*2*3*4
	3! = 1*2*3
	2! = 1*2
	1! = 1

这样的原理让阶乘这个数慢慢的被筛选到最后一步，因为看这个

	.....
	......
	........
	4! = 1*2*3*4
	3! = 1*2*3
	2! = 1*2
	1! = 1

不管是多大的阶乘数，都是在 1*... 开始，所以就是以 1 这个阶乘数开始，但是，1 这个阶乘的数的值就等于 1 本身，然后，在每一次计算时，如果阶乘数大于 1 那么就让这个数像

	4! = 1*2*3*4
	3! = 1*2*3
	2! = 1*2
	1! = 1
这样来计算，直到最后的 1 对不对。
实现这个就是在 fact() 中调用自己中的 【 fact(n-1)*n 】(这个步骤很重要)这里就是实现了让阶乘数在每计算一次后，让自己变到 1 ，请仔细看看这一句。

*/

*注意*
		if(n>1)
		{
			f = fact(n-1)*n;	//4.让阶乘数在每调用自己时，让调用的这个阶乘数减去1在乘以自己，来达到 --->|◤5◥ 的方法。
		}else{
			f = 1;		//5.这里就是在阶乘数小于 1 时直接让自己等于 1 
		}
		return f;	//
		
	}

/*--------------------------------
这里还有段代码：

	long fact(int);
		
	int main()
	{	
		printf("%d", fact(4));
		return 0;
	}

	long fact(int n)
	{
		long f;
		printf("%d:%p\n", n ,&n);
		if(n>1)
		{
			f = fact(n-1*n);
			printf("%d:%p\n", n ,&n);
		}else{
			printf("%d:%p\n", n ,&n);
			f =1;
		}	
		return f;
	}

这段代码就更说明了以上递归的计算方法。请仔细参阅
-----------------------------------*/

===========================================================================*/




==============================================================================================
=============================================================================================
===========================【字符串 和 字符串函数】===========================================



				============在程序中字符串的定义

这个应该没有什么必要在说了，前面已经有说过这个字符串如何定义了。
可以用一个 char 来指定一个字符串，也可以用指针来指向一个字符串的首地址,还可以用数组来定义一个字符串。

比如，一个简单的字符串的定义：

int main()
{
	char str[20] = "this is a string!";
	printf("%c",str);

	return 0;

}

//这段代码将会输出 “this is a string!”这个字符串，这就是一个典型的数组定义的字符串


*注意*
	在字符串中，都是以字符中的【'\0'】来结尾，表示的是一个 ASCLL 值中的一个 \0 的字符
*注意*
【字符串常量】
		

			=============-------数组与指针
				
				--------------字符串的个数统计
看如下代码片段：

/*此函数有必要说一下*/
int main()
{
	char str[10]="Hello,boy!";
	int i;
	for(i=0; str[i]!='\0';i++);	
//****重点****
		因为在C语言中，每一个字符串的最后都是存在一个字符的，这个字符就是 \0 ，就因为有这个字符，才在这段代码中能够统计字符串的个数；所以在 for 循环中也就是让系统一个一个的去读出 str 中的每一个字符。

	然而，就因为在字符串中有 \0 这个字符，所以在这个 for 循环中，条件为【当 str 这个字符串读到 \0 这个结尾的字符】时就停止读取，来达到统计字符的效果，
还有，在这个应用中，会在实际中经常用上，所以必须掌握。
****重点****
	printf("%d",i);

	return 0;
}

或用指针：
int main()
{
	char *str = "Hello,boy!" ;
*注意*
	在定义指针的时候，只有在定义时才能给指针定义字符串
*注意*
	int i;
	for(i=0; *(str+i)!='\0';i++);	//这种方法是访问 str 中的地址
      ||for(i=0; str[i]!='\0';i++);	//这种方法是直接取 str 中的值
	printf("%d",i);
	return 0;
}

还能用 malloc() 函数来实现上述的功能：

如：
#include <stdio.h>
#include <malloc.h>

int main()
{
	char *str =NULL;
	int i;
	str = (char*)malloc(100);
	scanf("%s",str);
	for(i=0; *(str+i)!='\0'; i++);
	printf("%d",i);
	free(str);
	return 0;
}

//这个效果是让用户输入一个字符串，让系统来判断个数
详情的 malloc() 函数的使用请见书签 --->|◤6◥
//因为这里用了内存的分配

				--------------字符串中的大写转小写


片段：

#include <stdio.h>
#include <malloc.h>

int main()
{
	char *str =NULL;
	int i;
	str = (char*)malloc(100);
	scanf("%s",str);
	for(i=0; *(str+i)!='\0'; i++)
	{
		if(*(str+i) >= 'A' && *(str+i) <='Z')
		{
			*(str+i) = *(str+i) +	 ('a'-'A');	
		}
	
	}
	printf("%s",str);
	free(str);
	return 0;
}

//详情请编译此片段。与前面的单个字符转换一样。请见 --->|◤7◥

【字符串数组】
/*
	作业二：

	定义两个字符串数组
将用户输入的字符串，变成全部大写字母之后，复制到第二个字符数组中.

*/
			

				===================字符串的输入和输出
在 C 语言中的一些输入输出函数，如下：

·gets()				//获取键盘输入的字符串
·puts()
·scanf()与gets()的区别
·fgets()
·fputs()

如果要明白C 语言中的字符串的输入输出方法就需要掌握以上函数的用法

【gets()函数】(字符指针)(输入)

格式：

头文件:stdio.h(c)，cstdio(c++)

格式:char*gets(char*buffer);		//char* 叫字符指针

从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。【换行符不作为读取串的内容，读取的换行符被转换为NULL值】并由此来结束字符串。
读入成功，返回与参数buffer相同的指针;读入过程中遇到EOF(End-of-File)或发生错误，返回NULL指针。所以在遇到返回值为NULL的情况，要用ferror或feof函数检查是发生错误还是遇到EOF。


*注意*
	本函数可以无限读取，不会判断上限，所以程序员应该确保buffer的空间足够大，以便在执行读操作时不发生溢出。如果溢出，多出来的字符将被写入到堆栈中，这就覆盖了堆栈原先的内容，破坏一个或多个不相关变量的值。这个事实导致gets函数只适用于玩具程序。在V7的手册(1979年)中说明:为了向后兼容，gets删除换行符，gets并不将换行符存入缓冲区。

*注意*

且在 gets() 函数中，返回的值是一个指针，如果

	用户输入的多个字符串的函数
*注意*
	输入输出字符串有两种方法，一是直接用 char 关键字来定义一个数组字符串，二是利用mallco()函数来分配一个内存空间来储存字符串
*注意*
片段：

	char str[100]={0};	//将这个数组全部初始化为 0 
	
	gets(str);		//就是让用户输入一个字符串
,并且其中，str是所以就是 str 这个				//数组名
	printf("%s",);


*注意*
	在文件的指针操作中，C语言有【stdin(Standardoutput)标准输出】和【stdin(Standardinput标准输入)】,这个两个都是C语言在操作文件指针时所给出的标准缓冲区，也就是一个文件操作的指针

	也就是用户自己测试 C 时，可以用在文件上的两个标准( 下面的fgets() 和 fputs() 函数中就会用上文件的操作)

*注意*



【fgets()函数】（输入）

头文件：string.h(c)

格式：fgets(char *buf,int bufsize,file*stream);

char*buf:指向用来存储所得数据的地址
bufsize:整型数据，指明 buf 指向的字符数组的大小
stream:文件结构体指针，将要读取的文件流

片段：

	char str[100]={0};
	fgets(str, 100 ,stdin);
	printf("%s",str);

【puts()】(输出)

格式: puts(char*buf);

是直接输出那个缓冲区，也就是直接输出那个数组
如果这个函数与 printf() 函数同时使用可能会输出<null>

片段：

	char str[100]={0};
	gets(str);
	puts(str);

【fputs()】(输出)

	具有的功能是向指定的文件写入一个字符串（不自动写入字符串结束标记符‘\0’）。成功写入一个字符串后，文件的位置指针会自动后移，函数返回值为非负整数；否则返回EOF(符号常量，其值为-1)。

格式：fputs(char*buf, file ?);
	//这里我不是很清楚

片段：
	char str[100]={0};
	fgets(str,100, stdin);
	fputs(str,stdout);


【scanf() 与 gets()】

scanf()函数中，是遇见空格 || 回车 || 是空白的字符就停止输出

gets()函数中，是遇见回车时停止输出

比如：

	char str[]={0};
	scanf("%s", str);
      ||gets(str);
	
	
				----------输入输出的函数整理◤8◥

【输入函数】

1.scanf()

2.gets()

3.fgets()

【输出函数】

1.printf()

2.puts()

3.fputs()

				===============字符串处理函数

◤9◥基本的处理函数如下：

strlen()
strcat()
strcmp()
strncmp()
sprintf()
strstr()
strchr()

【strlen()】（StringLength）(计数)

strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0'为止，然后返回计数器值(长度不包含“\0”)。

头文件：string.h
格式：strlen （字符数组名）
功能：计算给定字符串的（unsigned int型）长度，不包括'\0'在内
说明：返回s的长度，不包括结束符NULL。


片段：
	char str[100]={0};
	gets(str);
	printf("%d:",strlen(str));	//特别注意，在这里是用 %d 输出


 【strcmp()】（比较）
原型：extern int strcmp(const char *s1,const char *s2);
头文件：string.h
格式：strcmp(const char *s1,const char * s2)
功能：将括号中的两个参数作比较，两个字符串向右逐个字符相比，（按ASCII值大小相比较）
      直到出现不同的字符或遇'\0'为止。
说明：

	若str1==str2，则返回 0 ；
	若str1>str2，则返回 正数；
	若str1<str2，则返回 负数。


*注意*
	strcmp(const char *s1,const char * s2)这里面只能比较字符串，即可用于比较两个字符串常量，或比较数组和字符串常量，不能比较数字等其他形式的参数。

*注意*

片段：

	char str[100]={0};
	char str1[200]="this is program for me";
	gets(str);
	if(strcmp(str,str1)== 0)
	{
		puts("两个字符串相等");		
	}else{
		puts("两个字符串不相等");
	}

【strncmp()】（比较）

原型：int strncmp ( const char * str1, const char * str2, size_t num );
格式：strncmp(const char * str1, const char * str2, size_t num );
功能：将括号内的两个参数作比较，两个字符串向右相比，（按ASCII值大小相比较）与 strmcp() 类似，但      是是在第三个参数中，定义比较的字符串的前多少个大小
说明：


	若str1==str2，则返回 0 ；
	若str1>str2，则返回 正数；
	若str1<str2，则返回 负数。

片段：

	char str[100]={0};
	char str1[200]="this is program for me";
	gets(str);
	if(strncmp(str,str1,3)== 0)
	{
		puts("两个字符串相等");		
	}else{
		puts("两个字符串不相等");
	}
*注意*
	在运行中，只比较参数是前 4 个的字符，并且不管后面的字符是不是相等的，也会是返回 0
*注意*



【strstr()】（查询子串）

格式：strstr(char *str1, char *str2)
功能：在串中查找指定字符串的第一次出现位置
说明：判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。
	
片段：

	char str[100]={0};
	char str1[200]="this is program for me";
	cahr *t=NULL;
	gets(str);
	if(t = strstr(str,str1))
	{
		printf("%s",t);		
	}
	
片段2：

	char str[100]={0};
	char str1[200]="this is program for me";
	cahr *t=NULL;
	gets(str);
	if(t = strstr(str,str1))
	{
		printf("%s",(int)(t-str));		
	}	
//这个是获取输入的字符串在查找的字符串中的第几个位置


【strchr()】（查询字串）

头文件： string.h
格式：char *strchr(char *str, int_val);
功能：在一个串中查找给定字符的第一个匹配之处
说明：返回首次出现c的位置的指针，返回的地址是被查找字符串指针开始的第一个与Val相同字符的指针，如果s中不存在c则返回NULL。

片段：


	char str[100]={0};
	char str1[200]="this is program for me";
	char *t=NULL;
	gets(str);
	if(t = strchr(str,4))
	{
		printf("%s",t);		
	}
	


【strcat()】(StringCatch)（连接）

头文件：string.h
格式：strcat(char*str1,char*str2)
功能：将括号内的两个参数连接起来
说明：返回 参数1与参数2

片段：

	char str[100]={0};
	char str1[200]="This is my add the string";
	gets(str);
	printf("%s",strcat(str1,str));




【sprintf()】（格式化输出）

头文件： stdio.h
原型：int sprintf( char *buffer, const char *format, [ argument] … )
格式：sprintf(char*buffer char*format ..);
[
buffer：char型指针，指向将要写入的字符串的缓冲区。
format：格式化字符串。
[argument]...：可选参数，可以是任何类型的数据。
]
功能：把格式化的数据写入某个字符串缓冲区

片段：

	char str[100]={0};
	char str1[200]="this is program for me";

	gets(str);
	sprintf(str1,"%s%s",str1,str,);
	puts(str1);




============================================================================================
=============================================================================================
===========================【文件操作】=====================================================

什么是文件？

什么是 C 语言中的标准文件？

				==============文件的打开和关闭
1.fopen()

2.fclose()

分别是打开和关闭文件


首先说 fopen() 函数的用法 ，（又是一个新函数了，还有就是从这里开始后面将会说很多很多的函数，哎，所以...）

fopen()


【函数原型】

	FILE * fopen(const char * path,const char * mode);

【返回值】

	文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno中。

*注意*

	一般而言，打开文件后会做一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以一般在fopen()后作错误判断及处理。

*注意*

		---------文件打开方式的参数◤10◥

【参数说明】

参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。

mode有下列几种形态字符串:

r 以只读方式打开文件，该文件必须存在。

r+ 以可读写方式打开文件，该文件必须存在。

rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。

w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。

w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。

a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾
，即文件原先的内容会被保留。（EOF符保留）

a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据
会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）

wb 只写打开或新建一个二进制文件；只允许写数据。

wb+ 读写打开或建立一个二进制文件，允许读和写。

ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。

wx 创建文本文件,只允许写入数据.

wbx 创建一个二进制文件,只允许写入数据.

w+x 创建一个文本文件,允许读写.

wb+x 创建一个二进制文件,允许读写。

w+bx 和"wb+x"相同

以x结尾的模式为独占模式,文件已存在或者无法创建(一般是路径不正确)都会导致fopen失败.文件以操作系统支持的独占模式


以下是个最基本的文件操作代码

片段：

	int main()
	{
		FILE *fp=NULL;		//定义一个文件的指针，因为 C 语言中访问文件都是用指针来操作
//将定义好的指针赋值为所需要打开的文件以及方式，切记，在路径上面要加上两根 \\ ，不然会被 C 理解成一个转义字符，会出错。还有就是后面的打开方式，详细的文件打开方式请参照 --->|◤10◥ 
		fp = fopen("c:\\CreateFile.txt","w");
//当然还要给打开文件后一个判断，就不详说了		
		if(fp == NULL)
		{
			puts("文件打开失败");	
			return 0;	//为什么要在这里结束掉程序呢? 
//∵如果在这个决策前面的文件都没有打开，那么打开文件的后面的操作企不是没有任何的作用
		}
		
		fclose(fp);	//这里一定要记住，打一个文件并操作完后
				//一定要关闭这个文件，记住
				//fclose() 中的参数是所指针向打开文件的指针

		return 0;	//当然这里还是结束程序
	}


				==============文件的读写

1.putc()

2.getc()

它们分别是写入和读取文件中的字符
说到这里就要多说一下了关于 fputc() 和 fgetc()函数的用法



【putc()】

功能：
	输出一串字符到指定的流中

片段：

	#include <stdio.h>
	int main(void)
	{
		char msg[] = "Hello world\n";
		int i = 0;
		while (msg[i])
		{
			putc(msg[i++],stdout);
		}
		return 0;
	}

片段：

	int main()
	{
		FILE *fp = NULL;
		fp = fopen("c:\\combat.txt","w");
	
		putc('c',fp);	//将字符 c 添加到 combat.txt 文件中

		fclose(fp);
	}

片段：


	FILE *fp = NULL;
	char ch;
	fp = fopen("c:\\combat.txt","wt");
//将用户输入的多个字符添加到 combat.txt 文件中
	while(ch = getchar())
	{
		putc(ch,fp);
	}	

	fclose(fp);

	

putc()与fputc()等价


原型：
	int putc(int ch, FILE *fp);	//也就是一个和 puts() 一样

而【fputc()】

原型：
	int fputc(int ch,FILE*fp)

功能：
	在 fp 所指向的文件的当前读写位置写入一个字符。写入字符成功则函数返回值为该字符的ASCII值，写入字符不成功则返回值为 EOF 。


【getc()】

功能：
	从流中取字符

原型：
	 int getc(FILE *stream)


**注意**

	此函数被ISO C声明为一个宏，所以在用时不能将其做为函数指针传(有一些编用时不能将其做为函数指针传(有一些编译器将其以函数形式也给另说)。	

**注意**	

片段：

	
	FILE *fp = NULL;
	char ch;
	fp = fopen("c:\\combat.txt","wt");

	ch = getc(fp);
	while(ch!= EOF)
	{
		ch = getc(fp);
		putchar(ch);	
	}
	fclose(fp);

//从combat.txt 文件中获取所有的字符，并打印出来,同样 fgetc() 和这个效果是一样的


而【fgetc()】

从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节。

功能：
	从流中读取字符

原型：

	int fgetc(FILE *stream);

返回值：

	返回所读取的一个字节。如果读到文件末尾或者读取出错时返回EOF。

片段：
	
	FILE *fp = NULL;
	char ch;
	fp = fopen("c:\\combat.txt","wt");

	ch = fgetc(fp);
	while(ch!= EOF)
	{
		ch = fgetc(fp);	//这里仅仅是变成了 fgetc()
		putchar(ch);	
	}
	fclose(fp);




				===========文件结尾

文件的结尾前面有说过，就是在文件的最后一个字节时，C 语言会有一个 EOF 的字符来控制这个文件的结尾

当然，还有一个函数可以用来确定文件的结尾。




【feof()】

原型：
	int feof(FILE *stream);

功能：

	检测流上的文件结束符

片段：
//引用上一个代码片段
	FILE *fp = NULL;
	char ch;
	fp = fopen("c:\\combat.txt","wt");

	ch = fgetc(fp);
	while(!feof(fp))
	{
		ch = fgetc(fp);	//这里仅仅是变成了 fgetc()
		putchar(ch);	
	}
	fclose(fp);

				
				===================== fgets() 和 fputs() 使用
【fgets()】
//首先在使用这个函数的时候需要有指定的空间大小，也就是缓存空间

原型：
	char *fgets(char *buf, int bufsize, FILE *stream);
 
返回值：
	1.成功，则返回第一个参数  buf 
	2.在读字符时遇到 end-of-file ，则 EOF 指示器被设置，如果还没读入任何字符就遇到这种情况，则 buf 保持原来的内容，返回 NULL
	3.如果发生读入错误，error 指示器被设置，返回 NULL，buf 的值可能被改变

功能：
	stream文件流指针体指向文件内容地址的偏移原则
如果使用fgets()读取某个文件，第一次读取的bufsize为5，而文件的第一行有10个字符（算上'\n'），那么读取文件的指针会偏移至当前读取完的这个字符之后的位置。也就是第二次再用fgets()读取文件的时候，则会继续读取其后的字符。而，如果使用fgets() 读取文件的时候bufsize大于该行的字符总数加2（多出来的两个，一个保存文件本身的'\n'换行，一个保存字符串本身的结束标识'\0'），文件并不会继续读下去，仅仅只是这一行读取完，随后指向文件的指针会自动偏移至下一行。

片段：
	FILE *fp = NULL;
	char ch;
	char str[100]={0};	//定义一个缓冲区的大小为 100 
	fp = fopen("c:\\combat.txt","r");
	printf("%s", fgets(str,100,fp));
	fclose(fp);

【fputs()】

这个函数顾名思义，就是把一个字符串写进这个句柄（文件指针）中，
所以这个函数好学习，也好掌握，直接代码看

片段：
	FILE *fp = NULL;
	char ch;
	fp = fopen("c:\\combat.txt","w");	//因为要写入就要改变访问的参数
	fputs("This is sentence!",fp);
	fclose(fp);



**
上面说的都很快，函数也很多了，文件操作中函数的确很多，所以下来要多操作多理解，会用一个函数是很简单，也很快，但是要运用自如，就需要多做所以就先说说这个



				◤12◥
==============================【文件读写函数的总结】==========================================
---------------------------------------------------------------------------------------------


--------------- putc()

	1.输出数组中的字符串，（可用循环来一个一个的访问数组下标输出字符串）
	  参数一是数组名，参数二是标准输出流

	2.在文件操作时可以将一个字符添加一文件中
	  参数一是字符，参数二是句柄
	  文件操作时用 w 打开

	3.将用户输入的多个字符添加到文件中

*注意*
	添加只能是一个字符，不能是一串字符或是一个变量存放的多个字符
*注意*

1.
	

	char str[]="Hello World!";
	int i=0;
	while(str[i])
	putc(str[i++],stdout);
	fclose(fr); 

2.
	

	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","w");
	putc('a',fr)
	fclose(fr); 

3.

	FILE *fr = NULL;
	char ch;
	fr = fopen("d:\\all the c\\file\\combat.txt","wt");
	while(ch = getchar())
	{
		putc(ch,fr);
	}	

	fclose(fr);
	


----------------- fputc()

	1.只用于在文件操作时对文件中句柄位置添加一个字符   
	  参数成功则返回该字符的ASCII码，不成功则返回 EOF
	  文件操作时用 w 打开 


1.

 	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","w");
	fputc('a',fr) ;
	fclose(fr); 

3.
	
	FILE *fr = NULL;
	char ch;
	fr = fopen("d:\\all the c\\file\\combat.txt","wt");
	while(ch = getchar())
	{
		fputc(ch,fr);
	}	

	fclose(fr);


---------------- getc()

	1.获取流中的一个字符（用于数组操作时不会错但是没有什么效果，主要用于文件操作中）
	  参数一是巨柄
	  文件操作时用 r 打开
	2.可用循环来获取所有的字符
	  
*注意*
	不能一次获取巨柄中的所有内容
*注意*

1.

	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	char ch;
	ch = getc(fr);
	putchar(ch); 
	fclose(fr); 


2.

	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	char ch;
	ch = getc(fr);
	while(ch!= EOF)
	{
		ch = getc(fr);
		putchar(ch);	
	}
	fclose(fr); 

------------------ fgetc()

	1.专用于在文件操作中，读取文件中的内容，如果操作成功返回读取字符，不成功返回 EOF 
	  不能一次获取巨柄中的所有内容，
	  并且用于操作时用 r 打开
	2.可用循环来获取所有的字符

1.
	
	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	char ch;
	ch = fgetc(fr);
	putchar(ch);	
	fclose(fr); 

2.
	
	FILE *fr=NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	char ch;
	ch = fgetc(fr);
	while(ch!= EOF)
	{
		ch = fgetc(fr);
		putchar(ch);	
	}
	fclose(fr); 

--------------------------------------------------------------------------------------------
============================================================================================
						
				【==========文件内部指针】

这里就只需要理解好什么是文件指针，什么是文件内部指针就行了，还有就是多操作，多操作，只有多操作才会对这些熟悉，才会打好基础，才能做更多的高深的程序，所以这个就是一句话了，最后还是一句话，多操作。。。。

				==============rewind() 函数的使用（文件的内部操作）
【rewind()】

功能：
	将文件内部指针恢复到文件内部的开关。
原型：
	rewind(FILE *);


片段：
//这里就直接用文件内部的指针把内容读取完一次
	FILE *fr = NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	if(!fr)
	{
		puts("文件打开失败！");	
		return 0;
	}
	while(!feof(fr))
	{
		putchar(getc(fr));
	}
	fclose(fr);
	return 0;

//这里再来比较一次，我们这个时候想要读取再次这个文件中的内容（这个片段肯定是失败的）
片段：
	FILE *fr = NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	if(!fr)
	{
		puts("文件打开失败！");	
		return 0;
	}
//这个是第一次全部读取出来的地方 
	while(!feof(fr))
	{
		putchar(getc(fr));
	}
//这里是第二次
	while(!feof(fr))
	{
		putchar(getc(fr));
	}


	fclose(fr);
	return 0;
	
//然而，编译了这段程序 并不能到达输出两次的效果，因为什么呢？因为，在文件操作中，是从文件中的第一个地方，文件指针出现的文件开头，就一个一个读取其中的数据，然后当第一次读取完了其中的数据后，文件中的指针就到了最后，现在又来读取一次，但是文件指针却在文件中的最后一个地方，所以就不能达到再次读取的效果，所以这里就需要有 rewind() 函数操作了，看下面的片段
				
片段：
//这里来用 rewind() 函数来操作一次文件中的内容，并多次读出文件中的内容 


	FILE *fr = NULL;
	fr = fopen("d:\\all the c\\file\\combat.txt","r");
	if(!fr)
	{
		puts("文件打开失败！");	
		return 0;
	}
//这个是第一次全部读取出来的地方 
	while(!feof(fr))
	{
		putchar(getc(fr));
	}
//这里很重要，在第一次读取完文件中的数据时，我们就把这个指针在指向文件的开头，所以下面的代码就能够再一次的读取文件中的内容了
	rewind(fr);

//这里是第二次全部读取出来的地方
	while(!feof(fr))
	{
		putchar(getc(fr));
	}


	fclose(fr);
	return 0;

这一下就完成了我们想要的结果了。

/*--------------------------
作业：
	利用文件操作，编写出一个HTML文档，并能够执行此文档。
1.利用C语言文件操作来创建一个HTML页面，并且用脚本语言自定义一个 fix 的小数固定的一个函数 
#include <stdio.h>
#include <string.h>
int main()
{	
	FILE *fh;
	fh = fopen("d:\\all the c\\file\\index.html","w");
	//用函数将其中的代码写进文件中
	fputs("<script>window.onload=function(){function fix(firstNum,fixedNum){var div= Math.pow(10,fixedNum);firstNum=Math.round(firstNum*div)/div;return firstNum;}var i=2.2345;var n=2;alert('This is start number'+i);alert('This is fixed number'+n);alert('The resule is :'+fix(i,n))}</script>",fh);
 	/*while(!feof(fh))
	{
			putchar(getc(fh));
		
	} */	
	fclose(fh);	
	return 0;
}
-----------------------*/

				===================随机存取 fseek() 和 ftell()


【fseek()】

功能：
	重定位流(数据流/文件)上的文件内部位置指针。.

原型：
	int fseek(FILE *stream, long offset, int fromwhere);

返回值：
	成功，返回 0 ，失败返回 -1，并设置一个errno 的值，可以用 perror() 函数输出错误

其中，在这个函数中 int fromwhere 的三个参数是：

0  ----  SEEK_SET：文件开头
1  ----  SEEK_CUR：当前位置
2  ----  SEEK_END：文件结尾

在此在说一个在第二个参数的时候，可以用 多少个字节 + L 来表示出将文件指针移动多少个字节附近，比如：

	fseek(fp,100L,0);把文件内部指针移动到离文件开头100字节处；
	fseek(fp,100L,1);把文件内部指针移动到离文件当前位置100字节处；
	fseek(fp,-100L,2);把文件内部指针退回到离文件结尾100字节处。

下面来用不同的方式来改变句柄的位置

片段：
//这个是第一种利用 fseek() 函数来确定句柄的位置

	FILE *fr = NULL;
	fr = fopen("c:\\combat.txt","wt");
	getc(fr);	//因为在文件操作中，每读取一次文件中的数据时，句柄就会移动该位置
	getc(fr);	//这里也是依旧
	fseek(fr,5,SEEK_CUR);	
	while(!feof(fr))
	{
		putchar(getc(fr));	
	}
	fclose(fr);

//在此就当 combat.txt 这个文件中有如下两句字符
www.baidu.com
www.google.com	

如果用了上面的这段代码输出的结果将是从 d 开始，因为在用 fseek() 函数之前，我们获取了再次文件中的内容，相反的也改变了句柄的位置，在第二个 w　处，然后我们在用了 fseek()函数之后，从当前向右移动了 5 个字节的位置，所以就在 d 这个地方停下了，结果就是从 du.com ... 一直输出了，再看第二个代码片段

片段：
	FILE *fr = NULL;
	fr = fopen("c:\\combat.txt","wt");
	getc(fr);	//因为在文件操作中，每读取一次文件中的数据时，句柄就会移动该位置
	getc(fr);	//这里也是依旧
	fseek(fr,-2,SEEK_CUR);	
	while(!feof(fr))
	{
		putchar(getc(fr));	
	}
	fclose(fr);

//还是向上面文件中的字符一样，读取了两次，然后在用 fseek() 函数向左移动了2 们，也就又变成了0 ，这时这个和 rewind() 函数的效果一样，都将句柄的位置定位在了第一个地方，所以也就会输出 www.baidu.com .... 了

至于其它的 int fromwhere 参数的使用就不在说明了，原理和上面的代码都相似

【ftell()】
这个函数的功能很简单，就是返回当前句柄的位置。返回的是一个整型的数，表示当前句柄的位置

原型：
	int ftell(FILE *stream);
		
就以上面的例子为例，返回当前句柄的位置
片段：

	FILE *fr = NULL;
	fr = fopen("c:\\combat.txt","wt");
	getc(fr);getc(fr);
	printf("当前句柄的位置：%d\n",	ftell(fr));
	while(!feof(fr))
	{
		putchar(getc(fr));	
	}
	fclose(fr);

/*===============================
==============【fseek() 和 ftell() 之获取任何文件的大小】


#include <stdio.h>

int main(int argc,char **argv){	/* 这里可能是第一次见到，主函数的参数，简单的说一下，第一个参数是键入的个数，第二个参数是地址的值，详情可以先去编译一下 main.c 这个文件，在键入的时候输入执行文件名时，还可以空格一次在键入一次文件名或任何字符名，依次类推，这个 argc 就会返回键入了多少个命名名*/

	FILE *fr = NULL;
	long len = 0;	//因为文件的大小可能很在，所以需要用上 long 型来表示
	if(argc != 2 )	//这里来判断是否有第二个参数，也就是键入文件名的参数
	{
		puts("没有找到你的第二个参数");
		return 0;	
	}
	fr = fopen(argv[1],"r");//当用户输入的有在输入命令中的第二个参数
				//再利用 fopen()打开这个参数，也就是打开这个文件
				//用数组的方法
	fseek(fr,0,2);		//将文件中的指针定位在文件最后
	len = ftell(fr);	//然后就告诉系统当前文件的指针在哪个位置
				//因为ftell() 这个函数返回的是句柄的位置
				//所以也就是返回的是句柄在当前的位置的大小 
	printf("当前文件的大小为 %d 个字节",len);	//最后，输出来
	fclose(fr);
	return 0;
}

//这个小程序可以用于所有的文件大小的检测中，不信试试

=================================*/

				================fgetpos() 

一个超级的 ftell() 函数，这个函数和 ftell() 函数一样，也就是返回句柄的位置来返回出文件的大小，但是又为什么说他是超级的 ftell() 函数呢，是因为在 ftell() 函数中即使是用 long 型的数据类型来存储文件大小的数据，也会发生错误，因为可能会不够大小，会溢出，但是用 fgetpos() 这个函数来获取文件的大小就不会出现数据的溢出，所以用 fgetpos() 函数的时候还需要定义一个超级整型的变量来存储数据

原型：
	int fgetpos(FILE *stream，fpos_t *filepos);
返回值：
	成功返回0，否则返回非0	


片段：
	
#include <stdio.h>

int main(int argc,char **argv){	
	FILE *fr = NULL;
	fpos_t len;	//这里是定义 fgetpos() 函数参数	

	if(argc != 2 )
	{
		puts("没有找到你的第二个参数");
		return 0;	
	}
	fr = fopen(argv[1],"r");
	fseek(fr,0,2);
	if(fgetpos(fr,&len)==0)		//这里的取地址就是取文件的指针的位置的地址，好知道当前文件指针的位置
	{
		printf("当前文件的大小为 %d 个字节",len);
	}
	fclose(fr);
	return 0;
}


/*========
	过后，需要了解文本文件和二进制文件，他们是什么
*/

				=======================fread() 和 fwrite()


【fread()】

顾名思义，就是读取文件中的内容

原型：

	size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;
	
参 数

buffer
	用于接收数据的内存地址
size
	要读的每个数据项的字节数，单位是字节
count
	要读count个数据项，每个数据项size个字节.（读取几次）
stream
	输入流

返回值：

	实际读取的元素个数。如果返回值与count不相同，则可能文件结尾或发生错误。从ferror和feof获取错误信息或检测是否到达文件结尾

片段:
int main(int argc,char **argv){	
	FILE *fr = NULL;
	fpos_t len;
	char str[500]="";	//定义一个文件中可以用的缓冲区间
	if(argc != 2 )
	{
		puts("没有找到你的第二个参数");
		return 0;	
	}
	fr = fopen(argv[1],"r");
	fseek(fr,0,2);
	if(fgetpos(fr,&len)==0)
	{
		printf("当前文件的大小为 %d 个字节",len);
	}
	rewind(fr);	//这一步不要忘了，还要把文件中的句柄放置在开头
	fread(str,len,1,fr);	//这几个参数的说明 str ，读取后将读取的内容存放在这个地方
				//len 因为上面这个程序段已经放置好了文件中的长度，也就是读取的字节了
				//1 就是读取这个文件中的内容一次，如果这个地方为 >1 那么，就会出错，因为文件中的句柄已经到了最后的地方了
				//fr 就不说了，文件的句柄
	printf("\n%s",str);
	fclose(fr);
	return 0;
}
	




【fwrite()】
也是听名字就知道，向文件中写入内容，和 fputs() 差不多，但是当然比　fputs()更好用了啊

原型：
	size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);


*注意*
	这个函数以二进制形式对文件进行操作，不局限于文本文件
*注意*

◤11◥
返回值：返回实际写入的数据块数目
（1）buffer：是一个指针，对fwrite来说，是要获取数据的地址；
（2）size：要写入内容的单字节数；
（3）count:要进行写入size字节的数据项的个数；
（4）stream:目标文件指针；
（5）返回实际写入的数据项个数count。

	fseek对此函数有作用，但是fwrite 函数写到用户空间缓冲区，并未同步到文件中，所以修改后要将内存与文件同步可以用fflush（FILE *fp）函数同步。

片段：

	FILE *fr = NULL;
	fpos_t len;
	char str[500]="this is a paragraph!";	//定义一个写入的字符串
	if(argc != 2 )
	{
		puts("没有找到你的第二个参数");
		return 0;	
	}
	fr = fopen(argv[1],"r");
	fseek(fr,0,2);
	if(fgetpos(fr,&len)==0)
	{
		printf("当前文件的大小为 %d 个字节",len);
	}
	rewind(fr);
	fwrite(str,20,1,fr);	//这里的每一个参数请看 --->|◤11◥
	fclose(fr);
	return 0;



==============================================================================================
=============================================================================================
====================【结构体和其它数据形式】==================================================



				=================结构体的定义和初始化

首先，什么是结构体，简单的来说，就是将分散的数据类型结合在一起，可以一次访问不同的数据类型
也就是把有关联的数据类型结合起来

就好比一个人，一个人有年龄，有姓名，有身高，有体重，比如说这里有5个人需要统计一下，那么如果不用结构体的话，我们就需要用 4*5 个变量来分别保存每个人的信息，这样，代码量就很多，但是如果用结构体来实现的话，就只需要 5 个变量，将年龄、姓名、身高、体重 4 个变量关联用结构体起来，然后再用一个用户自定的一个结构体名称当做是一个拥有这四个（年龄、姓名、身高、体重）数据的一个数据类型，然后就可以像用 int 定义一个整型的数据一样来定义这个拥有四个（年龄、姓名、身高、体重）数据的一个变量关键字,来声明，来当做普通的关键字一样来使用，企不是非常的方便,所以这个就是结构体的用处


关键字：
	1.struct 
	2.typedef

【struct】

格式：

	struct 结构体的名字
	{
		
	};


以上面的例子为例，定义一个有身高，有年龄和姓名的数据类型



片段：
	int main()
	{
		struct person		//1.定义一个属于自己的数据类型，并取名字为 person（这是其实就相当于在 main() 函数下的一个普通的数据类型的声明，就好像是 int 一样这样来用）
		{
//2.在 person　数据类型下在定义三个变量，一个变量是来存放年龄，一个变量是来存放身高，最后一个变量来存放姓名
			int age;	
			int height;
			char name[3];				
		}

		struct person i={20,170,"刘"};	//这里的这一步很重要，声明一个 person 关键字，是用 struct + person　来完成，也就是刚才用来声明 person 这个关键字的所有开头的节构 ， 因这里的 struct person 就在实际上真正的是代表了像 int,char,long ... ... 的用法了，也就成了一个变量声明的关键了，后面在跟变量名，并给这个变量名赋值，分别为 20：年龄， 170：身高   刘：姓名
		
//这个地方，访问所定义的变量的值，会有一点的不同， 需要像在JS  中一样，加个句点来访问定义变量 i 的关键字中的每一个变量名，简单来说，就是  i 点那个就是那个的值

		printf("%d\t%d\t%s",i.age,i.height,i.name);

		return 0;
	}

//上面在定义 i 这个变量的时候，还可以放在声明 person 的最后面空格加上变量名（可以多个），也不要忘了加上分号结束哦,和普通的变量的操作是一样的

**结构体可以在主函数的外面独立存在


		struct person
		{

			int age;	
			int height;
			char name[3];				
		} i;

而且 在赋值的时候也可以用不同的方法，就像下面

	i.age = 20;
	i.height = 170;
	
*注意*
	在这里给字符数组赋值的时候是给地址中的值赋值，所以需要给 person 中的 name 这个指针赋值
*注意*

	strcpy(i.name,"刘");


********************
***重点**************

在 struct 结构体中有 ：  【有名结构体】和【无名结构体】


【有名结构体】

格式：
	struct 结构体名字
	{
		...
		..

	};

需要说明的是，在这个种结构体下，可以用前面说的 struct + 结构体名 来定义多个变量，也可以在定义结构体的最后面加上变量名

比如：
	struct 结构体名字
	{
		...
		..

	} var1,var2,var3 .... ... ... ..;

*注意*
	在这样定义好了变量的时候就不能在主函数中，直接引用这个变量名给这个变量赋值了，这里就要多说一种给结构体变量赋值的操作

形如上	
	struct 结构体名字
	{
		...
		..

	} var1={Value1,Value2,Value3 ... ... ...};

	
*注意*


也可以
	struct  结构体名字  变量名


【无名结构体】（匿名结构体）

	struct
	{
		...
		..

	};

但是在这个结构体中，就是能像上面说的那样，去定义多个变量名，就只能是这样了

	struct
	{
		...
		..

	} var1,var2,var3 .... ... ... ..;




***重点**************


【typedef】

这个关键字的用法就比较“神奇”了，这个关键字可以把简单而复杂的数据类型的定义以及

在计算机编程语言中用来为复杂的声明定义简单的别名，与宏定义有些差异。它本身是一种存储类的关键字，与auto、extern、mutable、static、register等关键字不能出现在同一个表达式中。

格式：

	typedef 数据类型 别名


一个例子
	
	typedef int Mint;	//首先声明了一个整型类型的一个别叫 Mint  

	int main()
	{
		Mint Mi=0;	//用 Mint 与下面 int 所定义的数据的类型是一样的
		int i=0;

		printf("%d\t%d",Mi,i);	//打印出这两个变量的值
	
		return 0;
	}

当然，在某种情况下，typedef 常与 结构体齐用再来看个实例 

片段：
	typedef struct person
	{
		int age;
		char name[15];
	} per;

	int main()
	{
		per p1={20,"刘"};
		printf("%d\t%s",p1.age,p1.name);
		return 0;
	}


//其实，可以将上面的一串代码看成是这样的

	typedef				数据类型				别名

	typedef		struct person{int age;char name[15];}		person


应该就不难看懂了



				===============访问结构体成员

代码片段：

	typedef struct Person{
		int age;
		int height;
		int weight;
		char name[15];
	} person;
	
	int main()
	{
		person p;
		printf("请输入你的年龄");
		scanf("%d",&p.age);
		
		printf("请输入你的身高");
		scanf("%d",&p.height);

		printf("请输入你的体重");
		scanf("%d",&p.weight);

		printf("请输入你的姓名");
		scanf("%s",p.name);

		printf("年龄\t身高\t体重\t姓名\n");
		printf("%d\t%d\t%d\t%s",p.age,p.weight,p.height,p.name);		

		return 0;
	}


// 编译上面代码，仔细探索，仔细研究


				==================结构体数组

	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];
	} person;
	
	int main()
	{
		person p[2];
		int i,n;
		for(i=0; i<2; i++)
		{
			printf("请输入你的年龄");
			scanf("%d",&p[i].age);
			
			printf("请输入你的身高");
			scanf("%d",&p[i].height);
	
			printf("请输入你的体重");
			scanf("%d",&p[i].weight);
	
			printf("请输入你的姓名");
			scanf("%s",p[i].name);
			puts("\n----------------\n");
		}
		printf("年龄\t身高\t体重\t姓名\n");
		for(i=0; i<2; i++)
		{
			printf("%d\t%d\t%d\t%s\n",p[i].age,p[i].weight,p[i].height,p[i].name);	
		}
		getchar();		
		return 0;
	}

//也编译上面程序，仔细分析，仔细研究

		

				=====================结构体指针
【定义结构体指针】

和普通的指针定义的方法一样，都是关键字 ... ... 就不详说了具体看下面代码

片段：

	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];
	} person;


	int main()
	{
		person p;	//定义结构体指针时，需要注意的是，关键字就不在是int ,float..... 而是定义结构体对象的关键字了
		person *pp = &p;	//这里和普通的指针定义是一样的
		return 0;
	}



【访问结构体成员】

*注意*
	在结构体的指针中，访问结构体中的成员，就不能在用句点（.）来访问了，而是用（->）来访问结构体中的成员

*注意*

片段：
	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];
	} person;


	int main()
	{
		person p={20,100,170,"刘"};	//初始化一下这个变量
		person *pp = &p;//和上面的操作是一样的
	
		printf("姓名\t身高\t体重\t年龄\n");
//这里就是如何用结构体的指针来访问成员了，是用 （->）而不是句点(.)
		printf("%s\t%\td%\td%d",pp->name,pp->height,pp->weight,pp->age);

		return 0;
	}


		=============----------分配一个内存来存放结构体的数据，来访问

直接见代码：

代码片段：

	#include <stdio.h>
	#include <mallco.h>

	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];
	} person;
	
	int main()
	{
		person *pp = malloc(sizeof(struct Person/*或者是 person*/));
	
		memset(pp,0,sizeof(person));//因为分配的内存的随机的，所以需要用这个函数来调整一下
	
		puts("请分别输入姓名，年龄，体重，身高");
		scanf("%s",pp->name);
		scanf("%d",&pp->age);
		scanf("%d",&pp->height);
		scanf("%d",&pp->weight);

*注意*
	这是 ，用指针来访问成员的时候，【必须取它的地址】，因为库虽然 pp  是指针了，但是，pp 所指向的并不是每个值的地址，而只是每个值的类型，也就是指向的是其中的 int ，而不是 age，所以要取地址

*注意*

		printf("姓名，年龄，体重，身高分别是：%s%d%d%d",pp->name,&pp->age,&pp->height,&pp->weight);

		return 0;


	}
//详情内存分配请见 --->|◤6◥


				======================结构体做函数的参数

【函数参数传值】


上干货

代码片段：
	
	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];

	} person;
	
	void show(person);
	int main()
	{
		person p={10,20,"刘",50};
		show(p);
		printf("姓名：%s,身高：%d,年龄：%d,体重：%d\n",p.name,p.height,p.age,p.weight);
	
		return 0;
	}

	void show(person p)
	{
		p.age=50;
		printf("姓名：%s,身高：%d,年龄：%d,体重：%d\n",p.name,p.height,p.age,p.weight);
	}
	
//编译上面，代码就会发现两次输出的结果不一样，因为这个代码所传的是【值】，也就是将函数 show() 中的 p.age=50;  传给了它下面的那一行代码中，所以输出的结果有所不同

【函数参数传地址】

代码片段:

	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];

	} person;

	void show(person *);	//定义一个打印的结果的函数，并以 person 结构体用为关键字，并以指针为参数，也就是地址嘛

	int main()
	{
		person p={10,20,50,"刘"};
		show(&p);
		printf("姓名：%s,身高：%d,年龄：%d,体重：%d\n",p.name,p.height,p.age,p.weight);

		return 0;
	}

	void show(person *p)
	{
		p->age=50;
		printf("姓名：%s,身高：%d,年龄：%d,体重：%d\n",p->name,p->height,p->age,p->weight);
	}


//编译上面代码，可以看出两次输出的结果是一样的，因为这个代码传的是【地址】
更具体的传地址和传值见 --->|◤13◥

				===================结构体保存到文件


代码片段：
	
	typedef struct Person
	{
		int age;
		int height;
		int weight;
		char name[15];

	} person;
	
	
	int main()
	{
		FILE *fr=NULL;
		person p={10,20,50,"刘"};
		fr = fopen("d:\\all the c\\file\\combat.txt",w);
		fwrite(p,sizeof(p),1,fr);
		printf("姓名：%s,身高：%d,年龄：%d,体重：%d\n",p.name,p.height,p.age,p.weight);
		fclose(fr);
		return 0;
	}


/*---------------------------------------
一个小程序：

这个程序用上了前面学的许多的东西编译它吧！

#include <stdio.h>
#include <string.h>
typedef struct scroce{
	char name[5];
	int chinese;
	int math;
	int chemistry;
} scr;

int main()
{
	int i,n,t;
	int mainCycle=1;
	int len;
	i=0;
	puts("********************************************************************");
	puts("\t\t欢迎来到成绩统计的程序！ ");
	puts("***************************(小帖示：请按照一定的要求输入，不然。。。)");
	while(mainCycle)
	{
		printf("请输入你要统计的次数");
		scanf("%d",&n);
		printf("你需要统计的次数是：%d\n",n);
		t = n;
		scr one[t];
		printf("请输入你的成绩\n");
		puts("-----------------------------\n");
	
		for(i=0; i<t ; ++i)
		{
			puts("请输入你的姓名：");
		Goname:
			scanf("%s",one[i].name);
			len = strlen(one[i].name);
			if(len >6 )
			{
				puts("请输入一个正确的姓名,超过了 6 个字符");
				goto Goname;
			}
			puts("请输入你的 Chinese：");
		Gochinese:	
			scanf("%d",&one[i].chinese);
			if(one[i].chinese >150 || one[i].chinese < 0)
			{
				puts("Please enter number of a certain");
				goto Gochinese;
			}
			puts("请输入你的 Math：");	
		Gomath:
			scanf("%d",&one[i].math);
			if(one[i].math >150 || one[i].math < 0)
			{
				puts("Please enter number of a certain");
				goto Gomath;
			}
			puts("请输入你的 Chemistry：");
		Gochemistry:	
			scanf("%d",&one[i].chemistry);
			if(one[i].chemistry>150 || one[i].chemistry < 0)
			{
				puts("Please enter number of a certain");
				goto Gochemistry;
			}
			puts("--------------------------------\n");
		} 
		puts("********************\n");
		puts("*下列是你输入的成绩*\n");
		printf("姓名\tChinese\tMath\tChemistry\n");
		for(i=0; i<t; ++i)
		{
			printf("%s\t%4d\t%3d\t%6d\t",one[i].name,one[i].chinese,one[i].math,one[i].chemistry);
		}
			puts("\n\n");
	}	
	getchar();
	return 0;
}


--------------------------------------*/


				==================== 联合 

【联合定义】

	联合就是一个能在同一个存储空间里（但不同时）存储不同类型数据的数据类型



				=========== 枚举类型
【枚举类型的作用】

可以使用枚举类型声明代表整数常量的符号名称，可以提高程序的可读性


枚举格式：

	enum 枚举名{枚举类型，枚举类型2，... ...};

【枚举声明】

默认：
	枚举列表中的常量被指定为整数值 0、1、2
如
	emun color{red,green,blue};

//其每个分别输出的值是 0 、 1 、2

【赋值的枚举声明】

	emun color{red=100,green=200,blue=300};

//其每个分别输出的值是 100、200、300


【枚举变量】

和结构体的声明变量，一样

片段：

	emun color{red=100,green=200,blue=300};

	int main()
	{
		enum color mycolor;
		mycolor = red;
		printf("%d",mycolor);	
		return 0;
	}
	
//如果输出 mycolor 这个变量，那么将会输出的结果是 100


				====================函数的指针(指向函数的指针)

首先要说明一下这个函数指针是比较复杂的，即使在前面有说过函数，但是这个函数指针不是前面说的函数中指针做参数，这两个并不一样，就因为这个函数指针比较复杂，这里又只是入门笔记，所以就不会说太深奥

在C 语言中，只要是以数据类型存在的数据都会有一个地址，在此函数也不例外，函数也有它所有的地址，且很复杂，函数指针也就是指针某个函数的地址，并且一个函数指针可以作为多个同类型同参数的函数的指针

******重点******

	不管是什么样的函数指针，在此，每一个函数指针都必须与所以指向的函数的类型、参数必须是一致的，否则就会出错

*****重点*******

用一个例子来说明一下函数指针的简单用法

代码片段：

//这是一段将用户输入的字符改变大小写

	#include <stdio.h>
	void ToUpper(char);	//定义一个变成大写的函数
	void ToLower(char);	//定义一个变成小写的函数

//这里要注意，前面定义的两个函数的返回为无类型，这里的指针也要定义成返回为无类型；前面两个函数的参数是字符型，这里的函数指针中的参数也一定要是字符型，并且，在 C 语言中，括号的优先级比其它同等级的运算符要高，所以需要在定义指针时候用括号括起来， 让 pt 是一个指针

	void (*pt)(char);	

	int main()
	{
		char inputChar;
		inputChar = getchar();

		if(inputChar >= 'a' && inputChar <= 'z')
		{

			//如果用户输入的字符是在 a~z 之间，就让函数指针指向ToUpper() 这个函数，且要注意的是，这里的函数后面没有加括号，不是函数调用错误，而是将指针指向的是函数的地址，所以这里的函数后面就没的加括号
			pt = ToUpper;
		}
		else if(inputChar >='A' && inputChar <='Z')
		{
			pt = ToLower;	
		}

		pt(inputChar);	//最后就让通过决策的变量 inputChar 作为函数指针中的参数，也就是作满足条件后，函数指针所以指向的函数的参数
		return 0;
	}
//下面的两个实现大小写的转换
	void ToUpper(char ch)
	{
		putchar(ch-'a'+'A');	
	}
	void ToLower(char ch)
	{
		putchar(ch+'a'-'A');	
	}



==============================================================================================
=============================================================================================================================【位操作】====================================================


				===================位运算

按位 与( & )

按位 反( ～ )

按位 或( | )

按位 异或( ＾ )

左移 <<

右移 >>

【按位 反( ～ )】

	求反运算，求反运算符 ～ 为单目运算符，具有右结合性。 其功能是对参与运算的数的各二进制位按位求反。

例如 ～9 的运算为： ~(00001001)结果为：11110110

//因为 9 的二进制数为 (00001001)B， 所以在给这个 9 做取反运算则是将它的 0 变 1 ，1 变 0，所以结果将是 (11110110)B , (246)D,结果就为 246 


片段：
	int main()
	{
		char ch = 170; //10101010
			
		printf("%d", ~ch);

		return 0;
	}


【按位 与( & )】

	按位与运算，按位与运算符"&"是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1 ，否则为0。参与运算的数以补码方式出现。

例如：9 & 5 可写算式如下：00001001 (9的二进制补码) & 00000101 (5的二进制补码)　00000001 (1的二进制补码)  可见9&5=1。

//简单来说就是和上面的不一样，这个是将两个数比较，如果每一位上面【都是】 0 ，那么就返回 0 ，如果每一位上面都是 1 ，那么就返回 1 。
 

片段：
	main()
	{
		int a=9,b=5,c;
		c=a&b;
		printf("a=%d\nb=%d\nc=%d\n",a,b,c);
		return 0;
	}	



【按位 或( | )】

	按位或运算,按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码出现。

例如：9|5可写算式如下： 00001001|00000101
00001001
00000101

00001101 (十进制为13)可见9|5=13

//这个简单的来说就是两个数比较，只要在每一位上面【有】 1 则就返回 1 ，是 0 就返回 0

片段：
	main()
	{
		int a=9,b=5,c;
		c=a|b;
		printf("a=%d\nb=%d\nc=%d\n",a,b,c);
		return 0;
	}



【按位 异或( ＾ )】

	按位异或运算，按位异或运算符“＾”是双目运算符。其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。参与运算数仍以补码出现

例如 9^5 可写成算式如下：
00001001^00000101 00001100 (十进制为12)


00001001
00000101

//这个则是和 按位 或 很类似，但有不完全是，两个数据比较，只要每一位上有 1 则返回 1 ，0 则返回 0 ，但是，如果每一位上【都是】 1 ，则返回 0 【都是】 0 则返回 0 

片段：

	main()	
	{
		int a=9;
		a=a^15;
		printf("a=%d\n",a);
		return 0;
	}


因为在上面的每一个按位运算都是在 二进制位的基础上，所以需要将 位、字节、二进制它们是什么明白了，才能更好的理解这个按位运算


/*
提示：
	多做位运算的项目，或者是题目，多加深一下对位运算的理解
*/

				==========打开位

我相信这个很难很难，却实，这个位操作是难以理解的，就比如，前面的大小写字母的转换，在这个位操作来说，简直是小儿科，还真的，在前面将一个字符的大小写转换掉，还要加、减，如果用位的运算，跟本就没有那么的麻烦，就用一个例子说明

片段：

/*
分析
	'A’= 65 = 100 0001
	'a' = 97 = 110 0001
		   101 1111 利用一个与运算 将第二位的 1 变成 0 就成了
		
*/
	//将字母转换为大小写
	char ToUpper(char);
	
	int main()
	{
		putchar(ToUpper('a'));
		return 0;
	}
	
	char ToUpper(char ch)
	{
		return ch &95;	
	}


//结果会将小写的 a 转换为大写的 A ，就是这么简单
//同样大写转小写也是这么的简单

/*
	作业：
		利用位运算，做一个能将小写转大写，大写转小写的小程序
*/


				=============转置位和查看位

位转置，用上位异或的操作，将字母大小写改变了
片段：

	char change(char);

	int main()
	{
		putchar(change('a'));

		retrun 0;
	}

	char change(char ch)
	{
		return ch ^ 32;
	}

//这段代码就可以用位异或的运算来达到效果


【位的查看】
a:1 x 1 0 0 1 0 1

b:0 1 0 0 0 0 0 0

c:0 y 0 0 0 0 0 0

查看 x 上位的值，将　a 除了 x 的值以外，都将把其它的值变为 0 ，用按位与，也就是变为 c 然后看返回的值是多少，如果 y 是 0 则说明 x 的值是  ０ ，如果 y　是 １ ，则说明 x 为 １
在这个列表中，可以看出 x 和 y 的取舍应为多少，所以这个是作业了

/*
作业：
	查看位的值
*/





				=============左移、右移


最后一个了，就一个显示出一个数的二进制位吧

代码片段：

	#include <stdio.h>

	int main()
	{
		int i,n;
		puts("请输入你需要知道二进制数的十进制");
		scanf("%d",&i);
		for(n=0; n < 8 ; n++)
		{
			if( (i<<n) & 128)putchar('1');
			else putchar('0');	
		}
	
		return 0;
	}


========================================================================================================================================================================================================================================================================================================================================================================================
========================================================================================================================================================================================================================================================================================================================================================================================


C 语言的入门基础已经完了，之后的路就要自己去走了，这个笔记只是说出了 C 语言中的最基本的东西，还有更多的东西，并没有说出来，所以，加油! 加油! ... ...
