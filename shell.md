

# 变量

变量名和等号之间不能有空格

使用一个定义过的变量，只要在变量名前面加美元符号即可

readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变
unset 删除变量，unset 命令不能删除只读变量


## 局部变量

局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

##环境变量

所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

##shell变量 

shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

# 字符串

shell 字符串和 php 的字符串类似

单引号里的任何字符都会原样输出，字符串中的变量是无效的，不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号里可以有变量，可以出现转义字符


Shell```
#string 	# 获取字符串长度
string:1:4 	# 提取子字符串
```

# 数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开

# 传递参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……


```
$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数。
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
```


# 运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

表达式和运算符之间要有空格

乘号(*)前边必须加反斜杠(\)才能实现乘法运算
在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 

## 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

-eq	检测两个数是否相等，相等返回 true
-ne	检测两个数是否不相等，不相等返回 true
-gt	检测左边的数是否大于右边的，如果是，则返回 true
-lt	检测左边的数是否小于右边的，如果是，则返回 true
-ge	检测左边的数是否大于等于右边的，如果是，则返回 true
-le	检测左边的数是否小于等于右边的，如果是，则返回 true

## 布尔运算符

!	非运算，表达式为 true 则返回 false，否则返回 true
-o	或运算，有一个表达式为 true 则返回 true
-a	与运算，两个表达式都为 true 才返回 true

## 字符串运算符
=	检测两个字符串是否相等，相等返回 true
!=	检测两个字符串是否相等，不相等返回 true
-z	检测字符串长度是否为0，为0返回 true
-n	检测字符串长度是否为0，不为0返回 true
str	检测字符串是否为空，不为空返回 true。	


## 文件测试运算符


-b file	检测文件是否是块设备文件，如果是，则返回 true
-c file	检测文件是否是字符设备文件，如果是，则返回 true
-d file	检测文件是否是目录，如果是，则返回 true
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true
-p file	检测文件是否是有名管道，如果是，则返回 true
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true
-r file	检测文件是否可读，如果是，则返回 true
-w file	检测文件是否可写，如果是，则返回 true
-x file	检测文件是否可执行，如果是，则返回 true
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true
-e file	检测文件（包括目录）是否存在，如果是，则返回 true


# printf
printf 命令模仿 C 程序库（library）里的 printf() 程序。
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。



`printf  format-string  [arguments...]`
format-string: 为格式控制字符串
arguments: 为参数列表。


## printf的转义序列

\a	警告字符，通常为ASCII的BEL字符
\b	后退
\c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
\f	换页（formfeed）
\n	换行
\r	回车（Carriage return）
\t	水平制表符
\v	垂直制表符
\\	一个字面上的反斜杠字符
\ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd	表示1到3位的八进制值字符

# test

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。
[] 执行基本的算数运算

-eq	等于则为真
-ne	不等于则为真
-gt	大于则为真
-ge	大于等于则为真
-lt	小于则为真
-le	小于等于则为真


# 流程控制 

if
```
if condition
then 

else

fi
```
for
```
for var in :
do

done
```


while
```
while condition
do

done

```
until 循环执行一系列命令直至条件为 true 时停止。

Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：

```
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
```


# 函数

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。
```
[ function ] funname [()]

{

    action;

    [return int;]

}
```
函数返回值在调用该函数后通过 $? 来获得。

注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

--
$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
--
